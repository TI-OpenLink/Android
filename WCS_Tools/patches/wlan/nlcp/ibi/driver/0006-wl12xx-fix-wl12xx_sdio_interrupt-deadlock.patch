From 7f291b265e9f0da945a22ad0cd73fffe8130da4f Mon Sep 17 00:00:00 2001
From: Ido Reis <idor@ti.com>
Date: Thu, 9 Feb 2012 17:54:48 +0200
Subject: [PATCH 6/6] wl12xx: fix wl12xx_sdio_interrupt() deadlock

TODO: this patch breaks a bit the abstractions layer. we
should clean it later on...

before wl12xx_sdio_interrupt() calls wl1271_irq() directly,
it releases the host, and then reclaim it again. This might
deadlock on wl12xx_free_sdio_irq(), as it both claims the
host and waits for wl12xx_sdio_interrupt() to finish (which
tries to claim the already-claimed host).

Solve it by defering the wl1271_irq() call to a different
work. however, now we have to explicitly disable the irq
until wl1271_irq() is called, so add some code to handle
it...

Signed-off-by: Eliad Peller <eliad@wizery.com>
Signed-off-by: Ido Reis <idor@ti.com>
---
 drivers/net/wireless/ti/wlcore/main.c   |   11 +++++++++++
 drivers/net/wireless/ti/wlcore/sdio.c   |   13 ++++++-------
 drivers/net/wireless/ti/wlcore/wlcore.h |    1 +
 3 files changed, 18 insertions(+), 7 deletions(-)

diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c
index e0852b5..9b5768e 100644
--- a/drivers/net/wireless/ti/wlcore/main.c
+++ b/drivers/net/wireless/ti/wlcore/main.c
@@ -640,6 +640,16 @@ out:
 	return IRQ_HANDLED;
 }
 
+void wl1271_sdio_irq_work(struct work_struct *work)
+{
+	struct wl1271 *wl = container_of(work, struct wl1271, sdio_irq_work);
+
+	wl1271_irq(0, wl);
+
+	if (wl->inband_claimed)
+		wlcore_enable_interrupts(wl);
+}
+
 static int wl12xx_fetch_firmware(struct wl1271 *wl, bool plt)
 {
 	const struct firmware *fw;
@@ -4981,6 +4991,7 @@ struct ieee80211_hw *wlcore_alloc_hw(size_t priv_size)
 	INIT_DELAYED_WORK(&wl->elp_work, wl1271_elp_work);
 	INIT_WORK(&wl->netstack_work, wl1271_netstack_work);
 	INIT_WORK(&wl->tx_work, wl1271_tx_work);
+	INIT_WORK(&wl->sdio_irq_work, wl1271_sdio_irq_work);
 	INIT_WORK(&wl->recovery_work, wl1271_recovery_work);
 	INIT_DELAYED_WORK(&wl->scan_complete_work, wl1271_scan_complete_work);
 	setup_timer(&wl->tx_stuck_timer, wl12xx_tx_stuck, (unsigned long) wl);
diff --git a/drivers/net/wireless/ti/wlcore/sdio.c b/drivers/net/wireless/ti/wlcore/sdio.c
index a6405e0..53d2ccf 100644
--- a/drivers/net/wireless/ti/wlcore/sdio.c
+++ b/drivers/net/wireless/ti/wlcore/sdio.c
@@ -214,15 +214,11 @@ static void wl12xx_sdio_interrupt(struct sdio_func *func)
 	if (WARN_ON(!glue->handler || !glue->thread_fn))
 		return;
 
-	if (test_bit(WL1271_FLAG_SUSPENDED, &wl->flags))
-		sdio_disable_irq(func);
+	sdio_disable_irq(func);
 
 	ret = glue->handler(0, glue->irq_cookie);
-	if (ret == IRQ_WAKE_THREAD) {
-		sdio_release_host(func);
-		glue->thread_fn(0, glue->irq_cookie);
-		sdio_claim_host(func);
-	}
+	if (ret == IRQ_WAKE_THREAD)
+		ieee80211_queue_work(wl->hw, &wl->sdio_irq_work);
 }
 
 int wl12xx_sdio_request_irq(struct device *child,
@@ -257,6 +253,7 @@ static void wl12xx_sdio_free_irq(struct device *child)
 {
 	struct wl12xx_sdio_glue *glue = dev_get_drvdata(child->parent);
 	struct sdio_func *func = dev_to_sdio_func(glue->dev);
+	struct wl1271 *wl = platform_get_drvdata(glue->core);
 
 	printk("releasing sdio irq\n");
 	sdio_claim_host(func);
@@ -265,6 +262,8 @@ static void wl12xx_sdio_free_irq(struct device *child)
 	glue->thread_fn = NULL;
 	glue->irq_cookie = NULL;
 	sdio_release_host(func);
+
+	flush_work(&wl->sdio_irq_work);
 }
 
 
diff --git a/drivers/net/wireless/ti/wlcore/wlcore.h b/drivers/net/wireless/ti/wlcore/wlcore.h
index 3848027..6543c6b 100644
--- a/drivers/net/wireless/ti/wlcore/wlcore.h
+++ b/drivers/net/wireless/ti/wlcore/wlcore.h
@@ -204,6 +204,7 @@ struct wl1271 {
 	struct sk_buff_head deferred_tx_queue;
 
 	struct work_struct tx_work;
+	struct work_struct sdio_irq_work;
 	struct workqueue_struct *freezable_wq;
 
 	/* Pending TX frames */
-- 
1.7.0.4

