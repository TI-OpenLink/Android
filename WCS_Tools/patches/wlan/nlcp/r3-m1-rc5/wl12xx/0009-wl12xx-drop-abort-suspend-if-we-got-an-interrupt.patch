From f0ef08671cf71a0f4c9eb4b58bc530ded54d369d Mon Sep 17 00:00:00 2001
From: Eliad Peller <eliad@wizery.com>
Date: Wed, 11 May 2011 11:48:43 +0300
Subject: [PATCH 09/24] wl12xx: (drop?) abort suspend if we got an interrupt

---
 drivers/net/wireless/wl12xx/sdio.c |   15 +++++++++++++++
 1 files changed, 15 insertions(+), 0 deletions(-)

diff --git a/drivers/net/wireless/wl12xx/sdio.c b/drivers/net/wireless/wl12xx/sdio.c
index 74fd7c6..37d8dd0 100644
--- a/drivers/net/wireless/wl12xx/sdio.c
+++ b/drivers/net/wireless/wl12xx/sdio.c
@@ -324,8 +324,23 @@ static int wl1271_suspend(struct device *dev)
 	struct sdio_func *func = dev_to_sdio_func(dev);
 	struct wl1271 *wl = sdio_get_drvdata(func);
 	mmc_pm_flag_t sdio_flags;
+	unsigned long flags;
+	bool abort;
 	int ret = 0;
 
+	/*
+	 * if there is a pending irq work, we should abort the suspension.
+	 * (irq might come between mac80211 suspension and our suspension)
+	 * TODO: maybe remove it, since system will wake up anyway?
+	 */
+	spin_lock_irqsave(&wl->wl_lock, flags);
+	abort = !!test_bit(WL1271_FLAG_PENDING_WORK, &wl->flags);
+	spin_unlock_irqrestore(&wl->wl_lock, flags);
+	if (abort) {
+		wl1271_info("pending irq work - aborting suspend");
+		return -EBUSY;
+	}
+
 	wl1271_debug(DEBUG_MAC80211, "wl1271 suspend. wow_enabled: %d",
 		     wl->wow_enabled);
 
-- 
1.7.1

