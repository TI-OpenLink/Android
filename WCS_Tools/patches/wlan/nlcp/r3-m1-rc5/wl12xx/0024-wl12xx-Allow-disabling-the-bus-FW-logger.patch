From 1bb15d24157c54256a45f799ad5213bb5b9d4f89 Mon Sep 17 00:00:00 2001
From: Ido Yariv <ido@wizery.com>
Date: Tue, 17 May 2011 20:35:51 +0300
Subject: [PATCH 24/24] wl12xx: Allow disabling the bus FW logger

When possible, it is sometimes more convenient to retrieve logs by
connecting to the FW debug pins. This will not be possible if the FW
logger is configured to route logs to the host.

Allow disabling the bus FW logger via a debugfs entry. Please note that
this setting will only take effect after the FW reboots.

Signed-off-by: Ido Yariv <ido@wizery.com>
---
 drivers/net/wireless/wl12xx/debugfs.c |   62 +++++++++++++++++++++++++++++++++
 1 files changed, 62 insertions(+), 0 deletions(-)

diff --git a/drivers/net/wireless/wl12xx/debugfs.c b/drivers/net/wireless/wl12xx/debugfs.c
index c3f1946..76373ec 100644
--- a/drivers/net/wireless/wl12xx/debugfs.c
+++ b/drivers/net/wireless/wl12xx/debugfs.c
@@ -653,6 +653,67 @@ static const struct file_operations rx_streaming_always_ops = {
 	.llseek = default_llseek,
 };
 
+static ssize_t fwlog_enable_read(struct file *file, char __user *user_buf,
+				  size_t count, loff_t *ppos)
+{
+	struct wl1271 *wl = file->private_data;
+	u8 value;
+
+	if (wl->conf.fw_logger.output == WL12XX_FWLOG_OUTPUT_DBG_PINS)
+		value = 0;
+	else
+		value = 1;
+
+	return wl1271_format_buffer(user_buf, count, ppos, "%d\n", value);
+}
+
+static ssize_t fwlog_enable_write(struct file *file,
+				  const char __user *user_buf,
+				  size_t count, loff_t *ppos)
+{
+	struct wl1271 *wl = file->private_data;
+	char buf[16];
+	size_t len;
+	unsigned long value;
+	int ret;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+	buf[len] = '\0';
+
+	ret = kstrtoul(buf, 0, &value);
+	if (ret < 0) {
+		wl1271_warning("illegal value for fwlog_enable");
+		return -EINVAL;
+	}
+
+	if (value > 1) {
+		wl1271_warning("fwlog_enable value is not in valid range");
+		return -ERANGE;
+	}
+
+	wl1271_warning("FW log options will take effect after the FW reboots");
+
+	mutex_lock(&wl->mutex);
+
+	if (value)
+		wl->conf.fw_logger.output = WL12XX_FWLOG_OUTPUT_HOST;
+	else
+		wl->conf.fw_logger.output = WL12XX_FWLOG_OUTPUT_DBG_PINS;
+
+	mutex_unlock(&wl->mutex);
+
+	return count;
+}
+
+static const struct file_operations fwlog_enable_ops = {
+	.read = fwlog_enable_read,
+	.write = fwlog_enable_write,
+	.open = wl1271_open_file_generic,
+	.llseek = default_llseek,
+};
+
 static int wl1271_debugfs_add_files(struct wl1271 *wl,
 				     struct dentry *rootdir)
 {
@@ -765,6 +826,7 @@ static int wl1271_debugfs_add_files(struct wl1271 *wl,
 	DEBUGFS_ADD(driver_state, rootdir);
 	DEBUGFS_ADD(dtim_interval, rootdir);
 	DEBUGFS_ADD(beacon_interval, rootdir);
+	DEBUGFS_ADD(fwlog_enable, rootdir);
 
 	streaming = debugfs_create_dir("rx_streaming", rootdir);
 	if (!streaming || IS_ERR(streaming))
-- 
1.7.1

