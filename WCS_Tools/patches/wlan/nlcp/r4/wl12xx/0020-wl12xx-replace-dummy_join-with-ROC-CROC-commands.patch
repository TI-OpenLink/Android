From 5dabbb4083c1a62277a74d9c79643a7640d63d14 Mon Sep 17 00:00:00 2001
From: Eliad Peller <eliad@wizery.com>
Date: Mon, 4 Apr 2011 17:17:44 +0300
Subject: [PATCH 20/75] wl12xx: replace dummy_join with ROC/CROC commands

With ROC/CROC, we no longer need the dummy_join.
We enter ROC:
1. when going out of idle state.
2. after disassoc
3. on scan complete (when not associated)

We stop ROC:
1. when entering idle state
2. after association (before join)
3. before starting a scan

The ROC command automatically opens the filters, so we no
longer need to configure them explicitly.

Replace the WL1271_FLAG_JOINED with a anew WL1271_FLAG_ROC,
indicating the fw was configured to ROC. Wrap the
wl1271_cmd_roc/croc functions in order to clear/set
this flag automatically.
---
 drivers/net/wireless/wl12xx/cmd.c    |   41 +++++++++++++++++
 drivers/net/wireless/wl12xx/cmd.h    |    2 +
 drivers/net/wireless/wl12xx/main.c   |   81 +++++++++++++++++-----------------
 drivers/net/wireless/wl12xx/scan.c   |   19 +++++---
 drivers/net/wireless/wl12xx/wl12xx.h |    2 +-
 5 files changed, 97 insertions(+), 48 deletions(-)

diff --git a/drivers/net/wireless/wl12xx/cmd.c b/drivers/net/wireless/wl12xx/cmd.c
index 7c7ee45..d82b7e4 100644
--- a/drivers/net/wireless/wl12xx/cmd.c
+++ b/drivers/net/wireless/wl12xx/cmd.c
@@ -1510,3 +1510,44 @@ out_free:
 out:
 	return ret;
 }
+
+int wl1271_roc(struct wl1271 *wl)
+{
+	int ret = 0;
+
+	if (WARN_ON(test_bit(WL1271_FLAG_ROC, &wl->flags)))
+		return 0;
+
+	ret = wl1271_cmd_roc(wl);
+	if (ret < 0)
+		goto out;
+
+	ret = wl1271_cmd_wait_for_event(wl,
+					REMAIN_ON_CHANNEL_COMPLETE_EVENT_ID);
+	if (ret < 0) {
+		wl1271_error("cmd roc event completion error");
+		goto out;
+	}
+
+	set_bit(WL1271_FLAG_ROC, &wl->flags);
+
+out:
+	return ret;
+}
+
+int wl1271_croc(struct wl1271 *wl)
+{
+	int ret = 0;
+
+	if (WARN_ON(!test_bit(WL1271_FLAG_ROC, &wl->flags)))
+		return 0;
+
+	ret = wl1271_cmd_croc(wl);
+	if (ret < 0)
+		goto out;
+
+	clear_bit(WL1271_FLAG_ROC, &wl->flags);
+
+out:
+	return ret;
+}
diff --git a/drivers/net/wireless/wl12xx/cmd.h b/drivers/net/wireless/wl12xx/cmd.h
index ceecf6a..f69353c 100644
--- a/drivers/net/wireless/wl12xx/cmd.h
+++ b/drivers/net/wireless/wl12xx/cmd.h
@@ -73,6 +73,8 @@ int wl1271_cmd_set_ap_key(struct wl1271 *wl, u16 action, u8 id, u8 key_type,
 			  u8 key_size, const u8 *key, u8 hlid, u32 tx_seq_32,
 			  u16 tx_seq_16);
 int wl1271_cmd_set_peer_state(struct wl1271 *wl);
+int wl1271_roc(struct wl1271 *wl);
+int wl1271_croc(struct wl1271 *wl);
 int wl1271_cmd_add_peer(struct wl1271 *wl, struct ieee80211_sta *sta, u8 hlid);
 int wl1271_cmd_remove_peer(struct wl1271 *wl, u8 hlid);
 
diff --git a/drivers/net/wireless/wl12xx/main.c b/drivers/net/wireless/wl12xx/main.c
index b10a588..160d56a 100644
--- a/drivers/net/wireless/wl12xx/main.c
+++ b/drivers/net/wireless/wl12xx/main.c
@@ -1943,28 +1943,6 @@ void wl1271_configure_filters(struct wl1271 *wl, unsigned int filters)
 	}
 }
 
-static int wl1271_dummy_join(struct wl1271 *wl)
-{
-	int ret = 0;
-	/* we need to use a dummy BSSID for now */
-	static const u8 dummy_bssid[ETH_ALEN] = { 0x0b, 0xad, 0xde,
-						  0xad, 0xbe, 0xef };
-
-	memcpy(wl->bssid, dummy_bssid, ETH_ALEN);
-
-	/* pass through frames from all BSS */
-	wl1271_configure_filters(wl, FIF_OTHER_BSS);
-
-	ret = wl1271_cmd_role_start_sta(wl);
-	if (ret < 0)
-		goto out;
-
-	set_bit(WL1271_FLAG_JOINED, &wl->flags);
-
-out:
-	return ret;
-}
-
 static int wl1271_join(struct wl1271 *wl, bool set_assoc)
 {
 	int ret;
@@ -1988,8 +1966,6 @@ static int wl1271_join(struct wl1271 *wl, bool set_assoc)
 	if (ret < 0)
 		goto out;
 
-	set_bit(WL1271_FLAG_JOINED, &wl->flags);
-
 	if (!test_bit(WL1271_FLAG_STA_ASSOCIATED, &wl->flags))
 		goto out;
 
@@ -2029,12 +2005,8 @@ static int wl1271_unjoin(struct wl1271 *wl)
 	if (ret < 0)
 		goto out;
 
-	clear_bit(WL1271_FLAG_JOINED, &wl->flags);
 	memset(wl->bssid, 0, ETH_ALEN);
 
-	/* stop filtering packets based on bssid */
-	wl1271_configure_filters(wl, FIF_OTHER_BSS);
-
 out:
 	return ret;
 }
@@ -2052,8 +2024,12 @@ static int wl1271_sta_handle_idle(struct wl1271 *wl, bool idle)
 	int ret;
 
 	if (idle) {
-		if (test_bit(WL1271_FLAG_JOINED, &wl->flags)) {
-			ret = wl1271_unjoin(wl);
+		if (test_bit(WL1271_FLAG_ROC, &wl->flags)) {
+			ret = wl1271_croc(wl);
+			if (ret < 0)
+				goto out;
+
+			ret = wl1271_cmd_role_stop_dev(wl);
 			if (ret < 0)
 				goto out;
 		}
@@ -2068,18 +2044,17 @@ static int wl1271_sta_handle_idle(struct wl1271 *wl, bool idle)
 			goto out;
 		set_bit(WL1271_FLAG_IDLE, &wl->flags);
 	} else {
-		/* increment the session counter */
-		wl->session_counter++;
-		if (wl->session_counter >= SESSION_COUNTER_MAX)
-			wl->session_counter = 0;
-
 		/* The current firmware only supports sched_scan in idle */
 		if (wl->sched_scanning) {
 			wl1271_scan_sched_scan_stop(wl);
 			ieee80211_sched_scan_stopped(wl->hw);
 		}
 
-		ret = wl1271_dummy_join(wl);
+		ret = wl1271_cmd_role_start_dev(wl);
+		if (ret < 0)
+			goto out;
+
+		ret = wl1271_roc(wl);
 		if (ret < 0)
 			goto out;
 		clear_bit(WL1271_FLAG_IDLE, &wl->flags);
@@ -2156,11 +2131,28 @@ static int wl1271_op_config(struct ieee80211_hw *hw, u32 changed)
 				wl1271_warning("rate policy for channel "
 					       "failed %d", ret);
 
-			if (test_bit(WL1271_FLAG_JOINED, &wl->flags)) {
+			if (test_bit(WL1271_FLAG_STA_ASSOCIATED, &wl->flags)) {
 				ret = wl1271_join(wl, false);
 				if (ret < 0)
 					wl1271_warning("cmd join on channel "
 						       "failed %d", ret);
+			} else {
+				/*
+				 * change the ROC channel. do it only if we are
+				 * not idle. otherwise, CROC will be called
+				 * anyway.
+				 */
+				if (test_bit(WL1271_FLAG_ROC, &wl->flags) &&
+				    !(conf->flags & IEEE80211_CONF_IDLE)) {
+					ret = wl1271_croc(wl);
+					if (ret < 0)
+						goto out_sleep;
+
+					ret = wl1271_roc(wl);
+					if (ret < 0)
+						wl1271_warning("roc failed %d",
+							       ret);
+				}
 			}
 		}
 	}
@@ -2623,6 +2615,10 @@ static int wl1271_op_hw_scan(struct ieee80211_hw *hw,
 	if (ret < 0)
 		goto out;
 
+	/* cancel ROC before scanning */
+	if (test_bit(WL1271_FLAG_ROC, &wl->flags))
+		wl1271_croc(wl);
+
 	ret = wl1271_scan(hw->priv, ssid, len, req);
 
 	wl1271_ps_elp_sleep(wl);
@@ -3016,9 +3012,6 @@ static void wl1271_bss_info_changed_sta(struct wl1271 *wl,
 			if (ret < 0)
 				goto out;
 
-			/* filter out all packets not from this BSSID */
-			wl1271_configure_filters(wl, 0);
-
 			/* Need to update the BSSID (for filtering etc) */
 			if (bss_conf->assoc)
 				do_join = true;
@@ -3162,7 +3155,7 @@ static void wl1271_bss_info_changed_sta(struct wl1271 *wl,
 			/* restore the bssid filter and go to dummy bssid */
 			if (was_assoc) {
 				wl1271_unjoin(wl);
-				wl1271_dummy_join(wl);
+				wl1271_roc(wl);
 			}
 		}
 	}
@@ -3200,6 +3193,12 @@ static void wl1271_bss_info_changed_sta(struct wl1271 *wl,
 	}
 
 	if (do_join) {
+		/* disable ROC before joining */
+		if (test_bit(WL1271_FLAG_ROC, &wl->flags)) {
+			ret = wl1271_croc(wl);
+			if (ret < 0)
+				goto out;
+		}
 		ret = wl1271_join(wl, set_assoc);
 		if (ret < 0) {
 			wl1271_warning("cmd join failed %d", ret);
diff --git a/drivers/net/wireless/wl12xx/scan.c b/drivers/net/wireless/wl12xx/scan.c
index 9ffa827..897e7c6 100644
--- a/drivers/net/wireless/wl12xx/scan.c
+++ b/drivers/net/wireless/wl12xx/scan.c
@@ -33,6 +33,7 @@ void wl1271_scan_complete_work(struct work_struct *work)
 {
 	struct delayed_work *dwork;
 	struct wl1271 *wl;
+	int ret;
 
 	dwork = container_of(work, struct delayed_work, work);
 	wl = container_of(dwork, struct wl1271, scan_complete_work);
@@ -50,21 +51,27 @@ void wl1271_scan_complete_work(struct work_struct *work)
 	wl->scan.state = WL1271_SCAN_STATE_IDLE;
 	memset(wl->scan.scanned_ch, 0, sizeof(wl->scan.scanned_ch));
 	wl->scan.req = NULL;
-	ieee80211_scan_completed(wl->hw, false);
 
-	/* restore hardware connection monitoring template */
+	ret = wl1271_ps_elp_wakeup(wl);
+	if (ret < 0)
+		goto out;
+
 	if (test_bit(WL1271_FLAG_STA_ASSOCIATED, &wl->flags)) {
-		if (wl1271_ps_elp_wakeup(wl) == 0) {
-			wl1271_cmd_build_ap_probe_req(wl, wl->probereq);
-			wl1271_ps_elp_sleep(wl);
-		}
+		/* restore hardware connection monitoring template */
+		wl1271_cmd_build_ap_probe_req(wl, wl->probereq);
+	} else {
+		/* restore remain on channel */
+		wl1271_roc(wl);
 	}
+	wl1271_ps_elp_sleep(wl);
 
 	if (wl->scan.failed) {
 		wl1271_info("Scan completed due to error.");
 		ieee80211_queue_work(wl->hw, &wl->recovery_work);
 	}
 
+	ieee80211_scan_completed(wl->hw, false);
+
 out:
 	mutex_unlock(&wl->mutex);
 
diff --git a/drivers/net/wireless/wl12xx/wl12xx.h b/drivers/net/wireless/wl12xx/wl12xx.h
index 5ec6ca1..1c79d09 100644
--- a/drivers/net/wireless/wl12xx/wl12xx.h
+++ b/drivers/net/wireless/wl12xx/wl12xx.h
@@ -336,7 +336,7 @@ struct wl1271_ap_key {
 
 enum wl12xx_flags {
 	WL1271_FLAG_STA_ASSOCIATED,
-	WL1271_FLAG_JOINED,
+	WL1271_FLAG_ROC,
 	WL1271_FLAG_GPIO_POWER,
 	WL1271_FLAG_TX_QUEUE_STOPPED,
 	WL1271_FLAG_TX_PENDING,
-- 
1.7.0.4

