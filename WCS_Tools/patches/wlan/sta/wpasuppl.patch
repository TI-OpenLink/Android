diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/Android.mk wpa_supplicant_new/Android.mk
--- wpa_supplicant_original/Android.mk	2011-03-23 16:18:08.517403000 +0200
+++ wpa_supplicant_new/Android.mk	2011-03-23 16:18:34.943241000 +0200
@@ -41,6 +41,7 @@
 # OpenSSL is configured without engines on Android
 L_CFLAGS += -DOPENSSL_NO_ENGINE
 
+ifdef CONFIG_DRIVER_TI
 INCLUDES = $(LOCAL_PATH)
 INCLUDES += $(LOCAL_PATH)/src
 INCLUDES += $(LOCAL_PATH)/src/common
@@ -60,6 +61,37 @@
 INCLUDES += external/openssl/include
 INCLUDES += frameworks/base/cmds/keystore
 
+# Add include path for TI wlan driver 
+DK_ROOT = hardware/ti/wlan/$(BOARD_WLAN_DEVICE)
+OS_ROOT = $(DK_ROOT)/platforms
+STAD	= $(DK_ROOT)/stad
+UTILS	= $(DK_ROOT)/utils
+TWD	= $(DK_ROOT)/TWD
+COMMON  = $(DK_ROOT)/common
+TXN	= $(DK_ROOT)/Txn
+CUDK	= $(DK_ROOT)/CUDK
+LIB	= ../../lib
+
+INCLUDES += $(STAD)/Export_Inc
+INCLUDES += $(STAD)/src/Application \
+INCLUDES += $(UTILS) \
+INCLUDES += $(OS_ROOT)/os/linux/inc \
+INCLUDES += $(OS_ROOT)/os/common/inc \
+INCLUDES += $(TWD)/TWDriver \
+INCLUDES += $(TWD)/FirmwareApi \
+INCLUDES += $(TWD)/TwIf \
+INCLUDES += $(TWD)/FW_Transfer/Export_Inc \
+INCLUDES += $(TXN) \
+INCLUDES += $(CUDK)/configurationutility/inc \
+INCLUDES += $(CUDK)/os/common/inc \
+INCLUDES += external/openssl/include \
+INCLUDES += $(WPA_SUPPL_DIR_INCLUDE) \
+INCLUDES += $(DK_ROOT)/../lib
+
+L_CFLAGS += -DCONFIG_DRIVER_CUSTOM -DHOST_COMPILE -D__BYTE_ORDER_LITTLE_ENDIAN
+L_CFLAGS += -DWPA_SUPPLICANT_$(WPA_SUPPLICANT_VERSION)
+endif
+
 OBJS = config.c
 OBJS += src/utils/common.c
 OBJS += src/utils/wpa_debug.c
@@ -198,6 +230,13 @@
 OBJS_d += src/drivers/driver_broadcom.c
 endif
 
+ifdef CONFIG_DRIVER_TI
+L_CFLAGS += -DCONFIG_DRIVER_TI
+OBJS_d += src/utils/scanmerge.c
+OBJS_d += src/utils/shlist.c
+OBJS_d += src/drivers/driver_ti.c
+endif
+
 ifdef CONFIG_DRIVER_IPW
 L_CFLAGS += -DCONFIG_DRIVER_IPW
 OBJS_d += src/drivers/driver_ipw.c
@@ -1122,7 +1161,7 @@
 include $(CLEAR_VARS)
 LOCAL_MODULE := wpa_supplicant
 ifdef CONFIG_DRIVER_CUSTOM
-LOCAL_STATIC_LIBRARIES := libCustomWifi
+#LOCAL_STATIC_LIBRARIES := libCustomWifi
 endif
 ifneq ($(BOARD_WPA_SUPPLICANT_PRIVATE_LIB),)
 LOCAL_STATIC_LIBRARIES += $(BOARD_WPA_SUPPLICANT_PRIVATE_LIB)
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/.config wpa_supplicant_new/.config
--- wpa_supplicant_original/.config	2011-03-23 16:18:08.506400000 +0200
+++ wpa_supplicant_new/.config	2011-03-23 16:18:34.925234000 +0200
@@ -73,6 +73,10 @@
 # Example path for wlioctl.h; change to match your configuration
 #CFLAGS += -I/opt/WRT54GS/release/src/include
 
+# Add driver interface for Texas Instruments WiLink MCP2.X
+CONFIG_DRIVER_TI=y
+
+
 # Driver interface for Intel ipw2100/2200 driver
 #CONFIG_DRIVER_IPW=y
 
@@ -80,7 +84,7 @@
 #CONFIG_DRIVER_RALINK=y
 
 # Driver interface for generic Linux wireless extensions
-CONFIG_DRIVER_WEXT=y
+CONFIG_DRIVER_WEXT=n
 
 # Driver interface for Linux drivers using the nl80211 kernel interface
 #CONFIG_DRIVER_NL80211=y
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/ctrl_iface.c wpa_supplicant_new/ctrl_iface.c
--- wpa_supplicant_original/ctrl_iface.c	2011-03-23 16:18:08.541423000 +0200
+++ wpa_supplicant_new/ctrl_iface.c	2011-03-23 16:18:35.250154000 +0200
@@ -1634,8 +1634,6 @@
 	int ctrl_rsp = 0;
 	int reply_len;
 
-	wpa_printf(MSG_DEBUG, "CMD: %s", buf);
-
 	if (os_strncmp(buf, WPA_CTRL_RSP, os_strlen(WPA_CTRL_RSP)) == 0 ||
 	    os_strncmp(buf, "SET_NETWORK ", 12) == 0) {
 		wpa_hexdump_ascii_key(MSG_DEBUG, "RX ctrl_iface",
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/events.c wpa_supplicant_new/events.c
--- wpa_supplicant_original/events.c	2011-03-23 16:18:08.221398000 +0200
+++ wpa_supplicant_new/events.c	2011-03-23 16:18:35.674168000 +0200
@@ -696,6 +696,7 @@
 	}
 
 	wpa_supplicant_notify_scanning(wpa_s, 0);
+
 	if (wpa_supplicant_get_scan_results(wpa_s) < 0) {
 		if (wpa_s->conf->ap_scan == 2)
 			return;
@@ -717,10 +718,7 @@
 		wpa_printf(MSG_DEBUG, "New scan results available");
 		wpa_msg_ctrl(wpa_s, MSG_INFO, WPA_EVENT_SCAN_RESULTS);
 		wpa_supplicant_dbus_notify_scan_results(wpa_s);
-/* WPS availability is fetched from scan results. Reduce logging. */
-#ifndef ANDROID
 		wpas_wps_notify_scan_results(wpa_s);
-#endif
 	}
 
 	if ((wpa_s->conf->ap_scan == 2 && !wpas_wps_searching(wpa_s)))
@@ -805,9 +803,9 @@
 		timeout = 0;
 	} else if (!wpa_supplicant_enabled_networks(wpa_s->conf)) {
 		/*
-		 * No networks are enabled; short-circuit request so
-		 * we don't wait timeout seconds before transitioning
-		 * to INACTIVE state.
+		 * No networks are enabled and scan initiator isn't GUI; 
+         * short-circuit request so we don't wait timeout seconds 
+         * before transitioning to INACTIVE state.
 		 */
 		wpa_supplicant_set_state(wpa_s, WPA_INACTIVE);
 		return;
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/scan.c wpa_supplicant_new/scan.c
--- wpa_supplicant_original/scan.c	2011-03-23 16:18:09.140303000 +0200
+++ wpa_supplicant_new/scan.c	2011-03-23 16:18:41.857659000 +0200
@@ -92,10 +92,9 @@
 	enum wps_request_type req_type = WPS_REQ_ENROLLEE_INFO;
 #endif /* CONFIG_WPS */
 
-	wpa_printf(MSG_DEBUG, "%s: scan_req = %d, ap_scan = %d", __func__,
-		wpa_s->scan_req, wpa_s->conf->ap_scan);
+    
 
-	if (wpa_s->disconnected && !wpa_s->scan_req) {
+    if (wpa_s->disconnected && !wpa_s->scan_req) {
 		wpa_supplicant_set_state(wpa_s, WPA_DISCONNECTED);
 		return;
 	}
@@ -107,6 +106,9 @@
 		return;
 	}
 	scan_req = wpa_s->scan_req;
+    /* Save scan_req in scan_initiator, in order to pass to driver_ti
+     * and decide which scan to perform */
+    wpa_s->scan_initiator = wpa_s->scan_req;
 	wpa_s->scan_req = 0;
 
 	if (wpa_s->conf->ap_scan != 0 &&
@@ -165,6 +167,15 @@
 		return;
 	}
 
+	wpa_printf(MSG_DEBUG, "Starting AP scan (%s SSID)",
+		   ssid ? "specific": "broadcast");
+	if (ssid) {
+		wpa_hexdump_ascii(MSG_DEBUG, "Scan SSID",
+				  ssid->ssid, ssid->ssid_len);
+		wpa_s->prev_scan_ssid = ssid;
+	} else
+		wpa_s->prev_scan_ssid = BROADCAST_SSID_SCAN;
+
 #ifdef CONFIG_WPS
 	wps = wpas_wps_in_use(wpa_s->conf, &req_type);
 #endif /* CONFIG_WPS */
@@ -193,22 +204,14 @@
 
 	wpa_supplicant_notify_scanning(wpa_s, 1);
 
-	wpa_printf(MSG_DEBUG, "Starting AP scan (%s SSID)",
-		   ssid ? "specific": "broadcast");
-	if (ssid) {
-		wpa_hexdump_ascii(MSG_DEBUG, "Scan SSID",
-				  ssid->ssid, ssid->ssid_len);
-		wpa_s->prev_scan_ssid = ssid;
-	} else
-		wpa_s->prev_scan_ssid = BROADCAST_SSID_SCAN;
-
 	if (wpa_s->use_client_mlme) {
 		ieee80211_sta_set_probe_req_ie(wpa_s, extra_ie, extra_ie_len);
 		ret = ieee80211_sta_req_scan(wpa_s, ssid ? ssid->ssid : NULL,
 					     ssid ? ssid->ssid_len : 0);
 	} else {
 		wpa_drv_set_probe_req_ie(wpa_s, extra_ie, extra_ie_len);
-		ret = wpa_drv_scan(wpa_s, &ssid);
+		ret = wpa_drv_scan(wpa_s, ssid ? ssid->ssid : NULL,
+				   ssid ? ssid->ssid_len : 0);
 	}
 
 	wpabuf_free(wps_ie);
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/src/common/version.h wpa_supplicant_new/src/common/version.h
--- wpa_supplicant_original/src/common/version.h	2011-03-23 16:18:10.954226000 +0200
+++ wpa_supplicant_new/src/common/version.h	2011-03-23 16:18:35.872152000 +0200
@@ -2,5 +2,7 @@
 #define VERSION_H
 
 #define VERSION_STR "0.6.10"
+/* Changes: MCS00081143, MCS00080890 */
+/* Release date: 04/11/2010 */
 
 #endif /* VERSION_H */
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/src/drivers/driver.h wpa_supplicant_new/src/drivers/driver.h
--- wpa_supplicant_original/src/drivers/driver.h	2011-03-23 16:18:09.944357000 +0200
+++ wpa_supplicant_new/src/drivers/driver.h	2011-03-23 16:18:36.772085000 +0200
@@ -18,6 +18,7 @@
 #define WPA_SUPPLICANT_DRIVER_VERSION 3
 
 #include "defs.h"
+#include "config_ssid.h"
 
 #define AUTH_ALG_OPEN_SYSTEM	0x01
 #define AUTH_ALG_SHARED_KEY	0x02
@@ -369,7 +370,6 @@
         int ssi;
 };
 
-struct wpa_ssid;
 
 /**
  * struct wpa_driver_ops - Driver interface API definition
@@ -573,23 +573,6 @@
 	int (*scan)(void *priv, const u8 *ssid, size_t ssid_len);
 
 	/**
-	 * combo_scan - Request the driver to initiate combo scan
-	 * @priv: private driver interface data
-	 * @ssid_ptr: specific SSID to scan for (ProbeReq) or %NULL to scan for
-	 *	all SSIDs (either active scan with broadcast SSID or passive
-	 *	scan
-	 * @ssid_conf: SSID list from configuration
-	 *
-	 * Returns: 0 on success, -1 on failure
-	 *
-	 * Once the scan results are ready, the driver should report scan
-	 * results event for wpa_supplicant which will eventually request the
-	 * results with wpa_driver_get_scan_results().
-	 */
-	int (*combo_scan)(void *priv, struct wpa_ssid **ssid_prt,
-			   struct wpa_ssid *ssid_conf);
-
-	/**
 	 * get_scan_results - Fetch the latest scan results (old version)
 	 * @priv: private driver interface data
 	 * @results: pointer to buffer for scan results
@@ -1028,14 +1011,6 @@
 	void * (*init2)(void *ctx, const char *ifname, void *global_priv);
 
 	/**
-	 * set_beacon_int - Set beacon interval for adhoc mode
-	 * @priv: private driver interface data
-	 * @beacon_int: Beacon interval in TU (100 = 0.1024 sec)
-	 * Returns: 0 on success, -1 on failure
-	 */
-	int (*set_beacon_int)(void *priv, int beacon_int);
-
-	/**
 	 * get_interfaces - Get information about available interfaces
 	 * @global_priv: private driver global data from global_init()
 	 * Returns: Allocated buffer of interface information (caller is
@@ -1044,6 +1019,16 @@
 	 */
 	struct wpa_interface_info * (*get_interfaces)(void *global_priv);
 
+
+	/**
+	 * set_beacon_int - Set beacon interval for adhoc mode
+	 * @priv: private driver interface data
+	 * @beacon_int: Beacon interval in TU (100 = 0.1024 sec)
+	 * Returns: 0 on success, -1 on failure
+	 */
+	int (*set_beacon_int)(void *priv, int beacon_int);
+	
+	
 #ifdef ANDROID
     /**
      * driver_cmd - execute driver-specific command
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/src/drivers/driver_ti.c wpa_supplicant_new/src/drivers/driver_ti.c
--- wpa_supplicant_original/src/drivers/driver_ti.c	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant_new/src/drivers/driver_ti.c	2011-03-23 16:18:37.171008000 +0200
@@ -0,0 +1,3406 @@
+/*
+ * driver_ti.c
+ *
+ * Copyright 2001-2010 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "includes.h"
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#ifdef ANDROID
+#include <cutils/properties.h>
+#endif
+#include "driver_ti.h"
+#include "scanmerge.h"
+#ifdef CONFIG_WPS
+#include "wps_defs.h"
+#endif
+
+/*-------------------------------------------------------------------*/
+#define TI2WPA_STATUS(s)	(((s) != 0) ? -1 : 0)
+#define TI_CHECK_DRIVER(f,r)	\
+	if( !(f) ) { \
+		wpa_printf(MSG_ERROR,"TI: Driver not initialized yet"); \
+		return( r ); \
+	}
+
+/* internal functions */
+static int   wpa_driver_tista_set_network_mode(void *priv, int mode);
+static int   wpa_driver_tista_set_mode(void *priv, int mode);
+static int   wpa_driver_tista_get_ifflags(struct wpa_driver_ti_data *drv, int *flags);
+static int   wpa_driver_tista_set_ifflags(struct wpa_driver_ti_data *drv, int flags);
+static int   wpa_driver_tista_alternative_ifindex(struct wpa_driver_ti_data *drv, const char *ifname);
+static int   wpa_driver_tista_set_bssid(void *priv, const u8 *bssid);
+static int   wpa_driver_tista_own_ifindex(struct wpa_driver_ti_data *drv, int ifindex, struct nlmsghdr *h);
+static int   wpa_driver_tista_own_ifname(struct wpa_driver_ti_data *drv, struct nlmsghdr *h);
+static int   wpa_driver_tista_get_ifflags_ifname(struct wpa_driver_ti_data *drv, const char *ifname, int *flags);
+static int   wpa_driver_tista_set_ifflags_ifname(struct wpa_driver_ti_data *drv, const char *ifname, int flags);
+static int   wpa_driver_tista_send_oper_ifla(struct wpa_driver_ti_data *drv, int linkmode, int operstate);
+static int   wpa_driver_tista_event_wireless_michaelmicfailure(void *ctx, const char *ev, size_t len);
+static int   wpa_driver_tista_event_wireless_assocreqie(struct wpa_driver_ti_data *drv, const char *ev, int len);
+static int   wpa_driver_tista_event_wireless_pmkidcand(struct wpa_driver_ti_data *drv, const char *ev, size_t len);
+static int   wpa_driver_tista_event_wireless_assocrespie(struct wpa_driver_ti_data *drv, const char *ev, int len);
+static int   wpa_driver_tista_get_range(void *priv);
+static int   wpa_driver_tista_19_iw_point(struct wpa_driver_ti_data *drv, u16 cmd);
+static int   wpa_driver_tista_flush_pmkid(void *priv);
+static int   wpa_driver_tista_pmksa(struct wpa_driver_ti_data *drv, u32 cmd, const u8 *bssid, const u8 *pmkid);
+static void  wpa_driver_tista_event_receive(int sock, void *eloop_ctx, void *sock_ctx);
+static void  wpa_driver_tista_event_rtm_newlink(struct wpa_driver_ti_data *drv, void *ctx, struct nlmsghdr *h, size_t len);
+static void  wpa_driver_tista_event_rtm_dellink(struct wpa_driver_ti_data *drv, void *ctx, struct nlmsghdr *h, size_t len);
+static void  wpa_driver_tista_finish_drv_init(struct wpa_driver_ti_data *drv);
+static void  wpa_driver_tista_event_wireless(struct wpa_driver_ti_data *drv, void *ctx, char *data, int len);
+static void  wpa_driver_tista_event_link(struct wpa_driver_ti_data *drv, void *ctx, char *buf, size_t len, int del);
+static void  wpa_driver_tista_event_assoc_ies(struct wpa_driver_ti_data *drv);
+static void  wpa_driver_tista_event_wireless_custom(void *ctx, void *priv, char *custom);
+static void  wpa_driver_tista_add_scan_entry(struct wpa_scan_results *res, struct wpa_scan_data *data);
+static void  wpa_driver_tista_get_scan_mode(struct iw_event *iwe, struct wpa_scan_data *res);
+static void  wpa_driver_tista_get_scan_ssid(struct iw_event *iwe, struct wpa_scan_data *res, char *custom, char *end);
+static void  wpa_driver_tista_get_scan_freq(struct iw_event *iwe, struct wpa_scan_data *res);
+static void  wpa_driver_tista_get_scan_qual(struct iw_event *iwe, struct wpa_scan_data *res);
+static void  wpa_driver_tista_get_scan_encode(struct iw_event *iwe, struct wpa_scan_data *res);
+static void  wpa_driver_tista_get_scan_rate(struct iw_event *iwe, struct wpa_scan_data *res, char *pos, char *end);
+static void  wpa_driver_tista_get_scan_iwevgenie(struct iw_event *iwe, struct wpa_scan_data *res, char *custom, char *end);
+static void  wpa_driver_tista_get_scan_custom(struct iw_event *iwe, struct wpa_scan_data *res, char *custom, char *end);
+static void  wpa_driver_tista_disconnect(struct wpa_driver_ti_data *drv);
+static u8 *  wpa_driver_tista_giwscan(struct wpa_driver_ti_data *drv, size_t *len, u16* flags);
+/* */
+
+/* --------------------------------------------------------------------------*/
+
+/* Holds the information needed to initiate a connection (periodical) scan */
+static     TPeriodicScanParams g_periodicScanParams;
+
+/*-----------------------------------------------------------------------------
+Routine Name: check_and_get_build_channels
+Routine Description: get number of allowed channels according to a build var.
+Arguments: None
+Return Value: Number of channels
+-----------------------------------------------------------------------------*/
+static int check_and_get_build_channels( void )
+{
+
+#ifdef ANDROID
+    char prop_status[PROPERTY_VALUE_MAX];
+    char *prop_name = "ro.wifi.channels";
+    int  i, default_channels = NUMBER_SCAN_CHANNELS_FCC;
+
+    if( property_get(prop_name, prop_status, NULL) ) {
+        i = atoi(prop_status);
+        if( i != 0 )
+            default_channels = i;
+    }
+    return( default_channels );
+#else
+    return( NUMBER_SCAN_CHANNELS_FCC );
+#endif
+}
+
+static int wpa_driver_tista_cipher2wext(int cipher)
+{
+
+	switch (cipher) {
+	case CIPHER_NONE:
+		return IW_AUTH_CIPHER_NONE;
+	case CIPHER_WEP40:
+		return IW_AUTH_CIPHER_WEP40;
+	case CIPHER_TKIP:
+		return IW_AUTH_CIPHER_TKIP;
+	case CIPHER_CCMP:
+		return IW_AUTH_CIPHER_CCMP;
+	case CIPHER_WEP104:
+		return IW_AUTH_CIPHER_WEP104;
+	default:
+		return 0;
+	}
+}
+
+static int wpa_driver_tista_keymgmt2wext(int keymgmt)
+{
+	switch (keymgmt) {
+	case KEY_MGMT_802_1X:
+	case KEY_MGMT_802_1X_NO_WPA:
+#ifdef CONFIG_WPS
+	case KEY_MGMT_WPS:
+#endif
+		return IW_AUTH_KEY_MGMT_802_1X;
+	case KEY_MGMT_PSK:
+		return IW_AUTH_KEY_MGMT_PSK;
+	default:
+		return 0;
+	}
+}
+
+static int wpa_driver_tista_get_bssid(void *priv, u8 *bssid)
+{
+	struct wpa_driver_ti_data *drv = priv;
+    struct iwreq iwr;
+	int    ret = 0;
+
+    TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+
+	if (ioctl(drv->ioctl_sock, SIOCGIWAP, &iwr) < 0) {
+		perror("ioctl[SIOCGIWAP]");
+		ret = -1;
+	}
+	os_memcpy(bssid, iwr.u.ap_addr.sa_data, ETH_ALEN);
+
+	return ret;
+}
+
+static int wpa_driver_tista_get_ssid(void *priv, u8 *ssid)
+{
+	struct wpa_driver_ti_data *drv = priv;
+    struct iwreq iwr;
+	int    ret = 0;
+
+    TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.essid.pointer = (caddr_t) ssid;
+	iwr.u.essid.length = 32;
+
+	if (ioctl(drv->ioctl_sock, SIOCGIWESSID, &iwr) < 0) {
+		perror("ioctl[SIOCGIWESSID]");
+		ret = -1;
+	} else {
+		ret = iwr.u.essid.length;
+		if (ret > 32)
+			ret = 32;
+		/* Some drivers include nul termination in the SSID, so let's
+		 * remove it here before further processing. WE-21 changes this
+		 * to explicitly require the length _not_ to include nul
+		 * termination. */
+		if (ret > 0 && ssid[ret - 1] == '\0' &&
+		    drv->we_version_compiled < 21)
+			ret--;
+	}
+
+	return ret;
+}
+
+
+static int wpa_driver_tista_private_send( void *priv, u32 ioctl_cmd, void *bufIn, u32 sizeIn, void *bufOut, u32 sizeOut )
+{
+	struct wpa_driver_ti_data   *drv = (struct wpa_driver_ti_data *)priv;
+	ti_private_cmd_t            private_cmd;
+	struct                      iwreq iwr;
+	s32                         res;
+
+	private_cmd.cmd = ioctl_cmd;
+	if(bufOut == NULL)
+	    private_cmd.flags = PRIVATE_CMD_SET_FLAG;
+	else
+	    private_cmd.flags = PRIVATE_CMD_GET_FLAG;
+
+	private_cmd.in_buffer = bufIn;
+	private_cmd.in_buffer_len = sizeIn;
+	private_cmd.out_buffer = bufOut;
+	private_cmd.out_buffer_len = sizeOut;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+
+	iwr.u.data.pointer = &private_cmd;
+	iwr.u.data.length = sizeof(ti_private_cmd_t);
+	iwr.u.data.flags = 0;
+
+	res = ioctl(drv->ioctl_sock, SIOCIWFIRSTPRIV, &iwr);
+	if (0 != res)
+	{
+		wpa_printf(MSG_ERROR, "ERROR - wpa_driver_tista_private_send - error sending Wext private IOCTL to STA driver (ioctl_cmd = %x,  res = %d, errno = %d)", ioctl_cmd, res, errno);
+		drv->errors++;
+		if (drv->errors > MAX_NUMBER_SEQUENTIAL_ERRORS) {
+			drv->errors = 0;
+			wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
+		}
+		return -1;
+	}
+	drv->errors = 0;
+	wpa_printf(MSG_DEBUG, "wpa_driver_tista_private_send ioctl_cmd = %x  res = %d", ioctl_cmd, res);
+
+	return 0;
+}
+
+static int wpa_driver_tista_driver_start( void *priv )
+{
+	struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+	u32                       uDummyBuf;
+	s32                       res;
+
+	res = wpa_driver_tista_private_send(priv, DRIVER_START_PARAM, &uDummyBuf, sizeof(uDummyBuf), NULL, 0);
+
+	if (0 != res) {
+		wpa_printf(MSG_ERROR, "ERROR - Failed to start driver!");
+		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
+	}
+	else {
+		os_sleep(0, WPA_DRIVER_TI_WAIT_US); /* delay 400 ms */
+		wpa_printf(MSG_DEBUG, "wpa_driver_tista_driver_start success");
+	}
+	return res;
+}
+
+static int wpa_driver_tista_driver_stop( void *priv )
+{
+	struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+	u32                       uDummyBuf;
+	s32                       res;
+
+    res = wpa_driver_tista_private_send(priv, DRIVER_STOP_PARAM, &uDummyBuf, sizeof(uDummyBuf), NULL, 0);
+
+	if (0 != res) {
+		wpa_printf(MSG_ERROR, "ERROR - Failed to stop driver!");
+		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
+	}
+	else
+		wpa_printf(MSG_DEBUG, "wpa_driver_tista_driver_stop success");
+
+	return res;
+}
+
+/*-----------------------------------------------------------------------------
+Routine Name: wpa_driver_tista_oneShot_scan
+Routine Description: Launch one shot scan
+Arguments: 
+   priv - pointer to private data structure
+   ssid - ssid buffer
+   ssid_len - length of ssid
+Return Value: 0 on success, -1 on failure
+-----------------------------------------------------------------------------*/
+static int wpa_driver_tista_oneShot_scan( void *priv, const u8 *ssid, size_t ssid_len )
+{
+
+    struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+	struct wpa_supplicant     *wpa_s = (struct wpa_supplicant *)(drv->ctx);
+	struct wpa_ssid           *issid;
+	scan_Params_t             scanParams;
+	int                       scan_type, res, timeout, scan_probe_flag = 0;
+
+    TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+
+	os_memset(&scanParams, 0, sizeof(scan_Params_t));
+	/* Initialize scan parameters */
+	scan_type = drv->scan_type;
+	if (wpa_s->prev_scan_ssid != BROADCAST_SSID_SCAN) {
+		if (wpa_s->prev_scan_ssid->scan_ssid) {
+			scan_type = SCAN_TYPE_NORMAL_ACTIVE;
+			scan_probe_flag = 1;
+		}
+	}
+
+    scanParams.scanType         = scan_type;
+    scanParams.numOfChannels    = drv->scan_channels;
+	scanParams.probeReqNumber   = SCAN_DEFAULT_PROBE_REQUEST_NUM;
+	scanParams.probeRequestRate = RATE_MASK_UNSPECIFIED; /* Let the FW select */;
+    scanParams.desiredSsid.len  = 0;
+
+    /* Set scan initiator to be GUI */
+    scanParams.eScanClient = SCAN_CLIENT_GUI;
+
+	drv->force_merge_flag = 0; /* Set merge flag */
+
+	if ((scan_probe_flag && ssid) &&
+	    (ssid_len > 0 && ssid_len <= sizeof(scanParams.desiredSsid.str))) {
+		os_memcpy(scanParams.desiredSsid.str, ssid, ssid_len);
+		if (ssid_len < sizeof(scanParams.desiredSsid.str))
+			scanParams.desiredSsid.str[ssid_len] = '\0';
+		scanParams.desiredSsid.len = ssid_len;
+		drv->force_merge_flag = 1;
+	}
+
+	drv->last_scan = scan_type; /* Remember scan type for last scan */
+
+	res = wpa_driver_tista_private_send(priv, TIWLN_802_11_START_OS_SCAN_SET, &scanParams, sizeof(scanParams), NULL, 0);
+
+	if (0 != res)
+		wpa_printf(MSG_ERROR, "ERROR - Failed to do tista scan!");
+	else
+		wpa_printf(MSG_DEBUG, "wpa_driver_tista_scan success");
+
+	timeout = SCAN_DEFAULT_TIMEOUT;
+	wpa_printf(MSG_DEBUG, "Scan requested (ret=%d) - scan timeout %d sec",
+			res, timeout);
+	eloop_cancel_timeout(wpa_driver_tista_scan_timeout, drv, drv->ctx);
+	eloop_register_timeout(timeout, 0, wpa_driver_tista_scan_timeout,
+				drv, drv->ctx);
+	return res;
+
+}
+
+static void init_connection_scan_params(TPeriodicScanParams * periodicScanParams, struct wpa_ssid * pssid)
+{
+	
+    unsigned int     i;
+	int              curr_ssid_index = 0;
+	struct wpa_ssid  * curr_ssid = NULL;
+	int              max_configured_ssid_num = 0, ssids_configured_count = 0;
+
+    U8 channListBand5[] = PERIODIC_SCAN_CHANNELS_ARRAY_A_BAND;
+
+	periodicScanParams->uSsidNum = 0;
+	periodicScanParams->uSsidListFilterEnabled = 0; 
+
+    periodicScanParams->eScanClient = SCAN_CLIENT_SUPPLICANT;
+
+    periodicScanParams->uCycleNum = 0; /* infinite number of cycles */
+    periodicScanParams->bTerminateOnReport = TRUE;		
+	
+	/* Set cycle intervals */
+	periodicScanParams->uCycleIntervalMsec[0] = 0;
+    for (i = 1; i < PERIODIC_SCAN_MAX_INTERVAL_NUM; i++)
+    {
+	   periodicScanParams->uCycleIntervalMsec[i] = i * PERIODIC_SCAN_BASE_INTERVAL_MS;
+    }
+	
+	/* set threshold and other parameters */
+    periodicScanParams->iRssiThreshold              = PERIODIC_SCAN_RSSI_THRESHOLD;
+    
+    periodicScanParams->iSnrThreshold               = PERIODIC_SCAN_SNR_THRESHOLD;
+    periodicScanParams->uFrameCountReportThreshold  = PERIODIC_SCAN_FRAME_NUM_REPORT_THRESHODL;    
+    periodicScanParams->eBssType                    = BSS_ANY;
+    periodicScanParams->uProbeRequestNum            = PERIODIC_SCAN_PROBE_REQUEST_NUM;
+	
+	/* set channels */
+    periodicScanParams->uChannelNum = PERIODIC_SCAN_MAX_CHANNEL_NUM;
+    for (i = 0; i < MAX_NUM_OF_CHANNELS_2_4GHZ; i++)
+    {
+        /* G Band channels*/
+        periodicScanParams->tChannels[i].eBand              = RADIO_BAND_2_4_GHZ;
+        periodicScanParams->tChannels[i].uChannel           = i + 1;
+        periodicScanParams->tChannels[i].eScanType          = SCAN_TYPE_NORMAL_ACTIVE;
+        periodicScanParams->tChannels[i].uMinDwellTimeMs    = PERIODIC_SCAN_MIN_2_4_CHANNEL_DWELL_TIME_MS;
+        periodicScanParams->tChannels[i].uMaxDwellTimeMs    = PERIODIC_SCAN_MAX_2_4_CHANNEL_DWELL_TIME_MS;
+        periodicScanParams->tChannels[i].uTxPowerLevelDbm   = DEF_TX_POWER;
+    }
+
+    for (i = MAX_NUM_OF_CHANNELS_2_4GHZ; i < PERIODIC_SCAN_MAX_CHANNEL_NUM; i++)
+	{
+        /* A Band channels*/
+		periodicScanParams->tChannels[i].eBand              = RADIO_BAND_5_0_GHZ;
+		periodicScanParams->tChannels[i].uChannel           = channListBand5[i - MAX_NUM_OF_CHANNELS_2_4GHZ] ;
+		periodicScanParams->tChannels[i].eScanType          = SCAN_TYPE_NORMAL_ACTIVE;
+		periodicScanParams->tChannels[i].uMinDwellTimeMs    = PERIODIC_SCAN_MIN_5_CHANNEL_DWELL_TIME_MS;
+		periodicScanParams->tChannels[i].uMaxDwellTimeMs    = PERIODIC_SCAN_MAX_5_CHANNEL_DWELL_TIME_MS;
+		periodicScanParams->tChannels[i].uTxPowerLevelDbm   = DEF_TX_POWER;
+	}
+	
+
+	/* fill the list of SSIDs to search for */
+	curr_ssid_index = 0;
+	curr_ssid = pssid;
+
+	/* we want to configure maximum number of 5 SSIDs */
+	max_configured_ssid_num = PERIODIC_SCAN_MAX_SSID_NUM;
+	
+	/* Fill the list of perffered ssids */	
+	ssids_configured_count = 0;
+	while (ssids_configured_count < max_configured_ssid_num && curr_ssid != NULL)
+	{
+		/* --- */
+		/* add a new preffered ssid */
+		/* --- */
+		if (!curr_ssid->disabled)
+                {
+			/* set the SSID visaibility */
+			if (curr_ssid->scan_ssid == 1)
+				periodicScanParams->tDesiredSsid[ curr_ssid_index ].eVisability = SCAN_SSID_VISABILITY_HIDDEN;
+			else	
+				periodicScanParams->tDesiredSsid[ curr_ssid_index ].eVisability = SCAN_SSID_VISABILITY_PUBLIC;		
+		
+			/* set the ssid name */
+			periodicScanParams->tDesiredSsid[ curr_ssid_index ].tSsid.len = curr_ssid->ssid_len;
+			memcpy(	periodicScanParams->tDesiredSsid[ curr_ssid_index].tSsid.str, 
+				curr_ssid->ssid, 
+				periodicScanParams->tDesiredSsid[ curr_ssid_index ].tSsid.len);
+		
+			/* inc the number of SSIDs which we already configured */
+			ssids_configured_count++;
+		
+			/* advance to the next ssid */
+			curr_ssid_index++;
+		}		
+		curr_ssid = curr_ssid->next;
+	}
+
+	/* Update the number of preffered ssids according to what we filled earlier */
+	periodicScanParams->uSsidNum = curr_ssid_index;
+}
+
+/*-----------------------------------------------------------------------------
+ * Routine Name: wpa_driver_tista_connection_scan
+ * Routine Description: request connection (periodical) scan from driver
+ * Arguments: 
+ *    priv - pointer to private data structure
+ *    pssid: the head of the preffered ssid list
+ *    scan_req: the scan request initiator: 2=Ctrlf (GUI), other=supplicant
+ *    Return Value: 0 on success, -1 on failure
+ * -----------------------------------------------------------------------------*/
+static int wpa_driver_tista_connection_scan( void *priv, struct wpa_ssid * pssid)
+{
+
+    struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+	struct wpa_supplicant     *wpa_s = (struct wpa_supplicant *)(drv->ctx);	
+	struct wpa_ssid           *issid;
+	int i;
+	int scan_type, scan_probe_flag = 0;
+    int res = 0; 
+	
+    /* Initialize periodic scan parameters (use the global variable: 'g_periodicScanParams') */
+    os_memset(&g_periodicScanParams, 0, sizeof(g_periodicScanParams));
+    init_connection_scan_params(&g_periodicScanParams, pssid);
+
+    wpa_printf(MSG_DEBUG, "wpa_driver_tista_connection_scan. Scan params are set! uSsidNum = %d \n",g_periodicScanParams.uSsidNum);
+    	
+    /* save the last scan  type */
+    scan_type = drv->scan_type;	
+    drv->last_scan = scan_type; /* Remember scan type for last scan */
+    	   	
+    /* Perform the actual periodical scan */
+    res = wpa_driver_tista_private_send(priv, TIWLN_802_11_START_PERIODIC_SCAN_SET, &g_periodicScanParams, sizeof(g_periodicScanParams), NULL, 0);
+    if (0 != res) 
+    {			
+        wpa_printf(MSG_ERROR, "%s - Failed to do tista periodical scan!\n", __FUNCTION__);
+    } 
+    else 
+    {
+        wpa_printf(MSG_DEBUG, "%s - successfully sent START_PERIODIC_SCAN command.\n", __FUNCTION__);
+    }
+	return res;
+}
+
+
+/*-----------------------------------------------------------------------------
+Routine Name: wpa_driver_tista_scan
+Routine Description: request scan from driver
+Arguments: 
+   priv - pointer to private data structure
+   ssid - ssid buffer
+   ssid_len - length of ssid
+Return Value: 0 on success, -1 on failure
+-----------------------------------------------------------------------------*/
+static int wpa_driver_tista_scan( void *priv, const u8 *ssid, size_t ssid_len )
+{
+
+    struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+	struct wpa_supplicant     *wpa_s = (struct wpa_supplicant *)(drv->ctx);
+    int                       res;
+
+    TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+
+    if (wpa_s->scan_initiator == SCAN_INITIATOR_GUI)
+    {
+        res = wpa_driver_tista_oneShot_scan(priv, ssid, ssid_len);
+    }
+    else /* request from supplicant core */
+    {
+        res = wpa_driver_tista_connection_scan(priv, wpa_s->conf->ssid);
+    }
+
+    return res;
+}
+
+static int wpa_driver_tista_get_rssi(void *priv, int *rssi_data, int *rssi_beacon)
+{
+	u8                               bssid[ETH_ALEN];
+	struct wpa_driver_ti_data        *drv = (struct wpa_driver_ti_data *)priv;
+	TCuCommon_RoamingStatisticsTable buffer;
+
+	os_memset(&buffer, 0, sizeof(TCuCommon_RoamingStatisticsTable));
+	*rssi_data = 0;
+	*rssi_beacon = 0;
+	if (wpa_driver_tista_get_bssid(priv, bssid) == 0 &&
+		os_memcmp(bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) != 0) {
+		if(0 != wpa_driver_tista_private_send(priv, TIWLN_802_11_RSSI, NULL, 0,
+				&buffer, sizeof(TCuCommon_RoamingStatisticsTable))) {
+			wpa_printf(MSG_ERROR, "ERROR - Failed to get rssi level");
+			return -1;
+		}
+		*rssi_data = (s8)buffer.rssi;
+		*rssi_beacon = (s8)buffer.rssiBeacon;
+		wpa_printf(MSG_DEBUG, "wpa_driver_tista_get_rssi data %d beacon %d success",
+						*rssi_data, *rssi_beacon);
+	}
+	else {
+		wpa_printf(MSG_DEBUG, "no WiFi link.");
+		return -1;
+	}
+	return 0;
+}
+
+static int wpa_driver_tista_config_power_management(void *priv, TPowerMgr_PowerMode *mode, u8 is_set)
+{
+	struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+
+	if(is_set) /* set power mode */
+	{
+		if((mode->PowerMode) < POWER_MODE_MAX)
+		{
+			if(0 != wpa_driver_tista_private_send(priv, TIWLN_802_11_POWER_MODE_SET, 
+				mode, sizeof(TPowerMgr_PowerMode), NULL, 0))
+			{
+				wpa_printf(MSG_ERROR, "ERROR - Failed to set power mode");
+				return -1;
+			}
+		}
+		else
+		{
+			wpa_printf(MSG_ERROR, "ERROR - Invalid Power Mode");
+			return -1;
+		}
+	}
+	else /* get power mode */
+	{
+		if(0 != wpa_driver_tista_private_send(priv, TIWLN_802_11_POWER_MODE_GET, NULL, 0,
+			mode, sizeof(TPowerMgr_PowerMode)))
+		{
+			wpa_printf(MSG_ERROR, "ERROR - Failed to get power mode");
+			return -1;
+		}
+	}
+	wpa_printf(MSG_DEBUG, "wpa_driver_tista_config_power_management success");
+
+	return 0;
+}
+
+static int wpa_driver_tista_enable_bt_coe(void *priv, u32 mode)
+{
+	struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+	u32                       mode_set = mode;
+
+	/* Mapping the mode between UI enum and driver enum */
+	switch(mode_set)
+	{
+		case BLUETOOTH_COEXISTENCE_MODE_ENABLED:
+			mode_set = SG_OPPORTUNISTIC;
+			break;
+		case BLUETOOTH_COEXISTENCE_MODE_SENSE:
+			mode_set = SG_PROTECTIVE;
+			break;
+		case BLUETOOTH_COEXISTENCE_MODE_DISABLED:
+			mode_set = SG_DISABLE;
+			break;
+		default:
+			wpa_printf(MSG_DEBUG, "wpa_driver_tista_enable_bt_coe - Unknown Mode");
+			return -1;
+			break;
+	}
+
+	if(0 != wpa_driver_tista_private_send(priv, SOFT_GEMINI_SET_ENABLE, 
+		&mode_set, sizeof(u32), NULL, 0))
+	{
+		wpa_printf(MSG_ERROR, "ERROR - Failed to enable BtCoe");
+		return -1;
+	}
+	wpa_printf(MSG_DEBUG, "wpa_driver_tista_enable_bt_coe success");
+
+	return 0;
+}
+
+static int wpa_driver_tista_get_bt_coe_status(void *priv, u32 *mode)
+{
+	struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+	u32                       mode_get = 0;
+
+	if(0 != wpa_driver_tista_private_send(priv, SOFT_GEMINI_GET_CONFIG, NULL, 0,
+		&mode_get, sizeof(u32)))
+	{
+		wpa_printf(MSG_ERROR, "ERROR - Failed to get bt coe status");
+		return -1;
+	}
+	*mode = mode_get;
+	wpa_printf(MSG_DEBUG, "wpa_driver_tista_get_bt_coe_status mode %d success", *mode);
+
+	return 0;
+}
+
+/*-----------------------------------------------------------------------------
+Routine Name: prepare_filter_struct
+Routine Description: fills rx data filter structure according to parameter type
+Arguments:
+   priv - pointer to private data structure
+   type - type of mac address
+   dfreq_ptr - pointer to TRxDataFilterRequest structure
+Return Value: 0 - success, -1 - error
+-----------------------------------------------------------------------------*/
+static int prepare_filter_struct( void *priv, int type,
+					TRxDataFilterRequest *dfreq_ptr )
+{
+	const u8 *macaddr = NULL;
+	size_t   len = 0;
+	u8       mask;
+	int      ret = -1;
+
+	wpa_printf(MSG_DEBUG, "filter type=%d", type);
+	switch (type) {
+	case RX_SELF_FILTER:
+		macaddr = wpa_driver_tista_get_mac_addr(priv);
+		len = MAC_ADDR_LEN;
+		mask = 0x3F; /* 6 bytes */
+		break;
+	case RX_BROADCAST_FILTER:
+		macaddr = (const u8 *)"\xFF\xFF\xFF\xFF\xFF\xFF";
+		len = MAC_ADDR_LEN;
+		mask = 0x3F; /* 6 bytes */
+		break;
+	case RX_IPV4_MULTICAST_FILTER:
+		macaddr = (const u8 *)"\x01\x00\x5E";
+		len = 3;
+		mask = 0x7; /* 3 bytes */
+		break;
+	case RX_IPV6_MULTICAST_FILTER:
+		macaddr = (const u8 *)"\x33\x33";
+		len = 2;
+		mask = 0x3; /* 2 bytes */
+		break;
+	}
+
+	if (macaddr != NULL) {
+		dfreq_ptr->offset = 0;
+		dfreq_ptr->maskLength = 1;
+		dfreq_ptr->mask[0] = mask;
+		dfreq_ptr->patternLength = len;
+		os_memcpy( dfreq_ptr->pattern, macaddr, MAC_ADDR_LEN );
+		ret = 0;
+	}
+	return ret;
+}
+
+static int wpa_driver_tista_driver_rx_data_filter( void *priv, TRxDataFilterRequest *dfreq_ptr, u8 is_add )
+{
+	struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+	int                       cmd, res;
+
+	if (is_add) { /* add rx data filter */
+		cmd = TIWLN_ADD_RX_DATA_FILTER;
+		wpa_printf(MSG_DEBUG, "Add RX data filter");
+	}
+	else { /* remove rx data filter */
+		cmd = TIWLN_REMOVE_RX_DATA_FILTER;
+		wpa_printf(MSG_DEBUG, "Remove RX data filter");
+	}
+
+	res = wpa_driver_tista_private_send(priv, cmd, dfreq_ptr, sizeof(TRxDataFilterRequest), NULL, 0);
+	if (0 != res)
+		wpa_printf(MSG_ERROR, "ERROR - Failed to handle rx data filter command!");
+	else
+		wpa_printf(MSG_DEBUG, "%s success", __func__);
+	return res;
+}
+
+static int wpa_driver_tista_driver_enable_rx_data_filter( void *priv )
+{
+	struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+	u32                       val  = TRUE;
+	int                       res;
+
+	res = wpa_driver_tista_private_send(priv, TIWLN_ENABLE_DISABLE_RX_DATA_FILTERS,
+						&val, sizeof(u32), NULL, 0);
+	if (0 != res)
+		wpa_printf(MSG_ERROR, "ERROR - Failed to enable RX data filter!");
+	else
+		wpa_printf(MSG_DEBUG, "%s success", __func__);
+	return res;
+}
+
+static int wpa_driver_tista_driver_disable_rx_data_filter( void *priv )
+{
+	struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+	u32                       val = FALSE;
+	int                       res;
+
+	res = wpa_driver_tista_private_send(priv, TIWLN_ENABLE_DISABLE_RX_DATA_FILTERS,
+						&val, sizeof(u32), NULL, 0);
+	if (0 != res)
+		wpa_printf(MSG_ERROR, "ERROR - Failed to disable RX data filter!");
+	else
+		wpa_printf(MSG_DEBUG, "%s success", __func__);
+	return res;
+}
+
+static int wpa_driver_tista_driver_rx_data_filter_statistics( void *priv,
+				TCuCommon_RxDataFilteringStatistics *stats )
+{
+	struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+	int                       res;
+
+	res = wpa_driver_tista_private_send(priv, TIWLN_GET_RX_DATA_FILTERS_STATISTICS,
+		NULL, 0, stats, sizeof(TCuCommon_RxDataFilteringStatistics));
+	if (0 != res)
+		wpa_printf(MSG_ERROR, "ERROR - Failed to get RX data filter statistics!");
+	else
+		wpa_printf(MSG_DEBUG, "%s success", __func__);
+	return res;
+}
+
+/*-----------------------------------------------------------------------------
+Routine Name: wpa_driver_tista_driver_cmd
+Routine Description: executes driver-specific commands
+Arguments: 
+   priv - pointer to private data structure
+   cmd - command
+   buf - return buffer
+   buf_len - buffer length
+Return Value: actual buffer length - success, -1 - failure
+-----------------------------------------------------------------------------*/
+static int wpa_driver_tista_driver_cmd( void *priv, char *cmd, char *buf, size_t buf_len )
+{
+	struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+	int                       ret = -1, prev_events, flags;
+
+	wpa_printf(MSG_DEBUG, "%s %s", __func__, cmd);
+
+	if( os_strcasecmp(cmd, "start") == 0 ) {
+		wpa_printf(MSG_DEBUG,"Start command");
+		ret = wpa_driver_tista_driver_start(priv);
+		if( ret == 0 ) {
+			drv->driver_is_loaded = TRUE;
+			wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STARTED");
+		}
+		return( TI2WPA_STATUS(ret) );
+	}
+
+        TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+
+	if( os_strcasecmp(cmd, "stop") == 0 ) {
+		wpa_printf(MSG_DEBUG,"Stop command");
+		if ((wpa_driver_tista_get_ifflags(drv, &flags) == 0) &&
+		    (flags & IFF_UP)) {
+			wpa_printf(MSG_ERROR, "TI: %s when iface is UP", cmd);
+			wpa_driver_tista_set_ifflags(drv, flags & ~IFF_UP);
+		}
+		ret = wpa_driver_tista_driver_stop(priv);
+		if( ret == 0 ) {
+			scan_exit(drv); /* Clear scan cache */
+			drv->driver_is_loaded = FALSE;
+			wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STOPPED");
+		}
+	}
+	if( os_strcasecmp(cmd, "reload") == 0 ) {
+		wpa_printf(MSG_DEBUG,"Reload command");
+		ret = 0;
+		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
+	}
+	else if( os_strcasecmp(cmd, "macaddr") == 0 ) {
+		wpa_driver_tista_get_mac_addr(priv);
+		wpa_printf(MSG_DEBUG, "Macaddr command");
+		ret = sprintf(buf, "Macaddr = " MACSTR "\n", MAC2STR(drv->own_addr));
+		wpa_printf(MSG_DEBUG, "buf %s", buf);
+	}
+	else if( os_strcasecmp(cmd, "scan-passive") == 0 ) {
+		wpa_printf(MSG_DEBUG,"Scan Passive command");
+		drv->scan_type =  SCAN_TYPE_NORMAL_PASSIVE;
+		ret = 0;
+	}
+	else if( os_strcasecmp(cmd, "scan-active") == 0 ) {
+		wpa_printf(MSG_DEBUG,"Scan Active command");
+		drv->scan_type =  SCAN_TYPE_NORMAL_ACTIVE;
+		ret = 0;
+	}
+	else if( os_strcasecmp(cmd, "scan-mode") == 0 ) {
+		wpa_printf(MSG_DEBUG,"Scan Mode command");
+		ret = snprintf(buf, buf_len, "ScanMode = %u\n", drv->scan_type);
+		if (ret < (int)buf_len) {
+			return( ret );
+		}
+	}
+	else if( os_strcasecmp(cmd, "linkspeed") == 0 ) {
+		struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)(drv->ctx);
+
+ 		wpa_printf(MSG_DEBUG,"Link Speed command");
+		drv->link_speed = wpa_s->link_speed / 1000000;
+		ret = sprintf(buf,"LinkSpeed %u\n", drv->link_speed);
+		wpa_printf(MSG_DEBUG, "buf %s", buf);
+	}
+	else if( os_strncasecmp(cmd, "scan-channels", 13) == 0 ) {
+		int noOfChan;
+
+		noOfChan = atoi(cmd + 13);
+		wpa_printf(MSG_DEBUG,"Scan Channels command = %d", noOfChan);
+		if( (noOfChan > 0) && (noOfChan <= MAX_NUMBER_OF_CHANNELS_PER_SCAN) )
+			drv->scan_channels = noOfChan;
+		ret = sprintf(buf,"Scan-Channels = %d\n", drv->scan_channels);
+		wpa_printf(MSG_DEBUG, "buf %s", buf);
+	}
+	else if( os_strcasecmp(cmd, "rssi-approx") == 0 ) {
+		scan_result_t *cur_res;
+		struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)(drv->ctx);
+		scan_ssid_t *p_ssid;
+		int rssi, len;
+
+		wpa_printf(MSG_DEBUG,"rssi-approx command");
+
+		if( !wpa_s )
+			return( ret );
+		cur_res = scan_get_by_bssid(drv, wpa_s->bssid);
+		if( cur_res ) {
+			p_ssid = scan_get_ssid(cur_res);
+			if( p_ssid ) {
+				len = (int)(p_ssid->ssid_len);
+				rssi = cur_res->level;
+				if( (len > 0) && (len <= MAX_SSID_LEN) && (len < (int)buf_len)) {
+					os_memcpy((void *)buf, (void *)(p_ssid->ssid), len);
+					ret = len;
+					ret += snprintf(&buf[ret], buf_len-len, " rssi %d\n", rssi);
+				}
+			}
+		}
+	}
+	else if( os_strcasecmp(cmd, "rssi") == 0 ) {
+		u8 ssid[MAX_SSID_LEN];
+		scan_result_t *cur_res;
+		struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)(drv->ctx);
+		int rssi_data, rssi_beacon, len;
+
+		wpa_printf(MSG_DEBUG,"rssi command");
+
+		ret = wpa_driver_tista_get_rssi(priv, &rssi_data, &rssi_beacon);
+		if( ret == 0 ) {
+			len = wpa_driver_tista_get_ssid(priv, (u8 *)ssid);
+			wpa_printf(MSG_DEBUG,"rssi_data %d rssi_beacon %d", rssi_data, rssi_beacon);
+			if( (len > 0) && (len <= MAX_SSID_LEN) ) {
+				os_memcpy((void *)buf, (void *)ssid, len);
+				ret = len;
+				ret += sprintf(&buf[ret], " rssi %d\n", rssi_beacon);
+				wpa_printf(MSG_DEBUG, "buf %s", buf);
+				/* Update cached value */
+				if( !wpa_s )
+					return( ret );
+				cur_res = scan_get_by_bssid(drv, wpa_s->bssid);
+				if( cur_res )
+					cur_res->level = rssi_beacon;
+			}
+			else
+			{
+				wpa_printf(MSG_DEBUG, "Fail to get ssid when reporting rssi");
+				ret = -1;
+			}
+		}
+	}
+	else if( os_strncasecmp(cmd, "powermode", 9) == 0 ) {
+		u32 mode;
+		TPowerMgr_PowerMode tMode;
+
+		mode = (u32)atoi(cmd + 9);
+		wpa_printf(MSG_DEBUG,"Power Mode command = %u", mode);
+		if( mode < POWER_MODE_MAX )
+		{
+			tMode.PowerMode = (PowerMgr_PowerMode_e)mode;
+			tMode.PowerMngPriority = POWER_MANAGER_USER_PRIORITY;
+			ret = wpa_driver_tista_config_power_management( priv, &tMode, 1 );
+		}
+	}
+	else if (os_strncasecmp(cmd, "getpower", 8) == 0 ) {
+		u32 mode;
+		TPowerMgr_PowerMode tMode;
+
+		os_memset(&tMode, 0, sizeof(TPowerMgr_PowerMode));
+		ret = wpa_driver_tista_config_power_management( priv, &tMode, 0 );
+		if( ret == 0 ) {
+			ret = sprintf(buf, "powermode = %u\n", tMode.PowerMode);
+			wpa_printf(MSG_DEBUG, "buf %s", buf);
+		}
+	}
+	else if( os_strncasecmp(cmd, "btcoexmode", 10) == 0 ) {
+		u32 mode;
+
+		mode = (u32)atoi(cmd + 10);
+		wpa_printf(MSG_DEBUG,"BtCoex Mode command = %u", mode);
+		ret = wpa_driver_tista_enable_bt_coe( priv, mode );
+		if( ret == 0 ) {
+			drv->btcoex_mode = mode;
+		}
+	}
+	else if( os_strcasecmp(cmd, "btcoexstat") == 0 ) {
+		u32 status = drv->btcoex_mode;
+
+		wpa_printf(MSG_DEBUG,"BtCoex Status");
+		ret = wpa_driver_tista_get_bt_coe_status( priv, &status );
+		if( ret == 0 ) {
+			ret = sprintf(buf, "btcoexstatus = 0x%x\n", status);
+			wpa_printf(MSG_DEBUG, "buf %s", buf);
+		}
+	}
+	else if( os_strcasecmp(cmd, "rxfilter-start") == 0 ) {
+		wpa_printf(MSG_DEBUG,"Rx Data Filter Start command");
+		ret = wpa_driver_tista_driver_enable_rx_data_filter( priv );
+	}
+	else if( os_strcasecmp(cmd, "rxfilter-stop") == 0 ) {
+		wpa_printf(MSG_DEBUG,"Rx Data Filter Stop command");
+		ret = wpa_driver_tista_driver_disable_rx_data_filter( priv );
+	}
+	else if( os_strcasecmp(cmd, "rxfilter-statistics") == 0 ) {
+		TCuCommon_RxDataFilteringStatistics stats;
+		int len, i;
+
+		os_memset(&stats, 0, sizeof(TCuCommon_RxDataFilteringStatistics));
+		wpa_printf(MSG_DEBUG,"Rx Data Filter Statistics command");
+		ret = wpa_driver_tista_driver_rx_data_filter_statistics( priv, &stats );
+		if( ret == 0 ) {
+			ret = snprintf(buf, buf_len, "RxFilterStat: %u", (u32)stats.unmatchedPacketsCount);
+			for(i=0;( i < MAX_DATA_FILTERS );i++) {
+				ret += snprintf(&buf[ret], buf_len-ret, " %u", (u32)stats.matchedPacketsCount[i]);
+			}
+			ret += snprintf(&buf[ret], buf_len-ret, "\n");
+			if (ret >= (int)buf_len) {
+				ret = -1;
+			}
+		}
+	}
+	else if( os_strncasecmp(cmd, "rxfilter-add", 12) == 0 ) {
+		TRxDataFilterRequest dfreq;
+		char *cp = cmd + 12;
+		char *endp;
+		int type;
+
+		if (*cp != '\0') {
+			type = (int)strtol(cp, &endp, 0);
+			if (endp != cp) {
+				wpa_printf(MSG_DEBUG,"Rx Data Filter Add [%d] command", type);
+				ret = prepare_filter_struct( priv, type, &dfreq );
+				if( ret == 0 ) {
+					ret = wpa_driver_tista_driver_rx_data_filter( priv, &dfreq, 1 );
+				}
+			}
+		}
+	}
+	else if( os_strncasecmp(cmd, "rxfilter-remove",15) == 0 ) {
+		TRxDataFilterRequest dfreq;
+		char *cp = cmd + 15;
+		char *endp;
+		int type;
+
+		if (*cp != '\0') {
+			type = (int)strtol(cp, &endp, 0);
+			if (endp != cp) {
+				wpa_printf(MSG_DEBUG,"Rx Data Filter remove [%d] command", type);
+				ret = prepare_filter_struct( priv, type, &dfreq );
+				if( ret == 0 ) {
+					ret = wpa_driver_tista_driver_rx_data_filter( priv, &dfreq, 0 );
+				}
+			}
+		}
+	}
+	else {
+		wpa_printf(MSG_DEBUG,"Unsupported command");
+	}
+	return ret;
+}
+
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+/*-----------------------------------------------------------------------------
+Routine Name: wpa_driver_tista_set_probe_req_ie
+Routine Description: set probe request ie for WSC mode change
+Arguments:
+   priv - pointer to private data structure
+   ies - probe_req_ie data
+   ies_len - ie data length
+Return Value: actual buffer length - success, -1 - failure
+-----------------------------------------------------------------------------*/
+static int wpa_driver_tista_set_probe_req_ie(void *priv, const u8* ies, size_t ies_len)
+{
+	struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+
+#ifdef CONFIG_WPS
+	TWscMode WscModeStruct;
+
+        TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+
+	if ((!ies || (0 == ies_len)) && (NULL == drv->probe_req_ie)) {
+		return 0;
+	}
+
+	if (ies && drv->probe_req_ie) {
+		size_t len = wpabuf_len(drv->probe_req_ie);
+		u8* data = (u8*)wpabuf_head(drv->probe_req_ie);
+		if ((ies_len == len) && (0 == os_memcmp(ies, data, ies_len))) {
+			return 0;
+		}
+	}
+
+	os_memset(&WscModeStruct, 0, sizeof(TWscMode));
+
+	if (!ies || (0 == ies_len)) {
+		WscModeStruct.WSCMode = TIWLN_SIMPLE_CONFIG_OFF;
+	} else {
+		const size_t head_len = 6; /* probeReqIe head: dd xx 00 50 f2 04 */
+		u8 *pos, *end;
+		u16 password_id = 0;
+		size_t min_len = 0;
+
+		pos = (u8*)ies + head_len; /* Find the WSC mode in probe_req_ie by password_id */
+		end = (u8*)ies + ies_len;
+		while (pos < end) {
+			if (ATTR_DEV_PASSWORD_ID == WPA_GET_BE16(pos)) {
+				password_id = WPA_GET_BE16(pos+4);
+				break;
+			}
+			pos += (4 + WPA_GET_BE16(pos+2));
+		}
+		WscModeStruct.WSCMode = (DEV_PW_PUSHBUTTON == password_id)?TIWLN_SIMPLE_CONFIG_PBC_METHOD:TIWLN_SIMPLE_CONFIG_PIN_METHOD;
+
+		pos = (u8*)ies + head_len;
+		min_len = ies_len - head_len;
+		if (min_len > sizeof(WscModeStruct.probeReqWSCIE)) {
+			min_len = sizeof(WscModeStruct.probeReqWSCIE);
+		}
+		os_memcpy(WscModeStruct.probeReqWSCIE, pos, min_len);
+	}
+
+	wpa_hexdump(MSG_DEBUG, "SetProbeReqIe:WscModeStruct", (u8*)&WscModeStruct, sizeof(TWscMode));
+	if(0 == wpa_driver_tista_private_send(priv, SITE_MGR_SIMPLE_CONFIG_MODE, (void*)&WscModeStruct, sizeof(TWscMode), NULL, 0)) {
+		/* Update the cached probe req ie */
+		wpabuf_free(drv->probe_req_ie);
+		drv->probe_req_ie = NULL;
+
+		if (ies && ies_len) {
+			drv->probe_req_ie = wpabuf_alloc(sizeof(WscModeStruct.probeReqWSCIE));
+			if (drv->probe_req_ie) {
+				wpabuf_put_data(drv->probe_req_ie, ies, ies_len);
+			}
+		}
+	} else {
+		wpa_printf(MSG_ERROR, "ERROR - Failed to set wsc mode!");
+		return -1;
+	}
+#endif
+	return 0;
+}
+#endif
+
+/**
+ * wpa_driver_tista_finish_drv_init - More initializations.
+ * @ctx: context to be used when calling wpa_supplicant functions,
+ * e.g., wpa_supplicant_event()
+ * @ifname: interface name, e.g., wlan0
+ * Returns: Pointer to private data, %NULL on failure
+ */
+static void wpa_driver_tista_finish_drv_init(struct wpa_driver_ti_data *drv)
+{
+	int flags;
+
+	if (wpa_driver_tista_get_ifflags(drv, &flags) != 0)
+    {
+        printf("Could not get interface '%s' flags\n", drv->ifname);
+    }		
+	else if (!(flags & IFF_UP)) 
+    {
+		if (wpa_driver_tista_set_ifflags(drv, flags | IFF_UP) != 0) 
+        {
+			printf("Could not set interface '%s' UP\n", drv->ifname);
+		} 
+        else 
+        {
+			/*
+			 * Wait some time to allow driver to initialize before
+			 * starting configuring the driver. This seems to be
+			 * needed at least some drivers that load firmware etc.
+			 * when the interface is set up.
+			 */
+			wpa_printf(MSG_DEBUG, "Interface %s set UP - waiting "
+				   "a second for the driver to complete "
+				   "initialization", drv->ifname);
+			sleep(1);
+		}
+	}
+	/*
+	 * Make sure that the driver does not have any obsolete PMKID entries.
+	 */
+	wpa_driver_tista_flush_pmkid(drv);
+
+	if (wpa_driver_tista_set_mode(drv, 0) < 0) {
+		printf("Could not configure driver to use managed mode\n");
+	}
+	wpa_driver_tista_get_range(drv);
+
+	/*
+	 * Unlock the driver's BSSID and force to a random SSID to clear any
+	 * previous association the driver might have when the supplicant
+	 * starts up.
+	 */
+	wpa_driver_tista_disconnect(drv);
+
+    drv->ifindex = if_nametoindex(drv->ifname);
+
+    if (os_strncmp(drv->ifname, "wlan", 4) == 0)
+    {
+		/*
+		 * Host AP driver may use both wlan# and wifi# interface in
+		 * wireless events. Since some of the versions included WE-18
+		 * support, let's add the alternative ifindex also the time being. 
+         * This may be removed at some point once it is believed that old 
+         * versions of the driver are not in use anymore.
+		 */
+		char ifname2[IFNAMSIZ + 1];
+		os_strlcpy(ifname2, drv->ifname, sizeof(ifname2));
+		os_memcpy(ifname2, "wifi", 4);
+		wpa_driver_tista_alternative_ifindex(drv, ifname2);
+	}
+	wpa_driver_tista_send_oper_ifla(drv, 1, IF_OPER_DORMANT);
+}
+
+static void wpa_driver_tista_disconnect(struct wpa_driver_ti_data *drv)
+{
+	struct iwreq iwr;
+	const u8     null_bssid[ETH_ALEN] = { 0, 0, 0, 0, 0, 0 };
+#ifndef ANDROID
+	u8 ssid[32];
+	int i;
+#endif
+
+	/*
+	 * Only force-disconnect when the card is in infrastructure mode,
+	 * otherwise the driver might interpret the cleared BSSID and random
+	 * SSID as an attempt to create a new ad-hoc network.
+	 */
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	if (ioctl(drv->ioctl_sock, SIOCGIWMODE, &iwr) < 0) {
+		perror("ioctl[SIOCGIWMODE]");
+		iwr.u.mode = IW_MODE_INFRA;
+	}
+
+	if (iwr.u.mode == IW_MODE_INFRA) {
+		/*
+		 * Clear the BSSID selection and set a random SSID to make sure
+		 * the driver will not be trying to associate with something
+		 * even if it does not understand SIOCSIWMLME commands (or
+		 * tries to associate automatically after deauth/disassoc).
+		 */
+		wpa_driver_tista_set_bssid(drv, null_bssid);
+#ifndef ANDROID
+		for (i = 0; i < 32; i++)
+			ssid[i] = rand() & 0xFF;
+		wpa_driver_tista_set_ssid(drv, ssid, 32);
+#endif
+	}
+}
+
+static int wpa_driver_tista_set_auth_param(struct wpa_driver_ti_data *drv,
+					  int idx, u32 value)
+{
+	struct iwreq iwr;
+	int          ret = 0;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.param.flags = idx & IW_AUTH_INDEX;
+	iwr.u.param.value = value;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWAUTH, &iwr) < 0) {
+        wpa_printf(MSG_ERROR, "ioctl[SIOCSIWAUTH]");
+		wpa_printf(MSG_ERROR, "WEXT auth param %d value 0x%x - ",
+			idx, value);
+		ret = errno == EOPNOTSUPP ? -2 : -1;
+	}
+
+	return ret;
+}
+
+static int wpa_driver_tista_set_wpa(void *priv, int enabled)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	int ret;
+
+    TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+	ret = wpa_driver_tista_set_auth_param(drv, IW_AUTH_WPA_ENABLED,
+					      enabled);
+	return ret;
+}
+
+static int wpa_driver_tista_set_auth_alg(void *priv, int auth_alg)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	int algs = 0, res;
+
+        TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+	if (auth_alg & AUTH_ALG_OPEN_SYSTEM)
+		algs |= IW_AUTH_ALG_OPEN_SYSTEM;
+	if (auth_alg & AUTH_ALG_SHARED_KEY)
+		algs |= IW_AUTH_ALG_SHARED_KEY;
+	if (auth_alg & AUTH_ALG_LEAP)
+		algs |= IW_AUTH_ALG_LEAP;
+	if (algs == 0) {
+		/* at least one algorithm should be set */
+		algs = IW_AUTH_ALG_OPEN_SYSTEM;
+	}
+
+	res = wpa_driver_tista_set_auth_param(drv, IW_AUTH_80211_AUTH_ALG,
+					     algs);
+
+	return res;
+}
+
+static int wpa_driver_tista_set_countermeasures(void *priv, int enabled)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+        TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+	ret = wpa_driver_tista_set_auth_param(drv,
+					      IW_AUTH_TKIP_COUNTERMEASURES,
+					      enabled);
+	return ret;
+}
+
+static int wpa_driver_tista_set_drop_unencrypted(void *priv,
+						int enabled)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+        TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+	/* Dm: drv->use_crypt = enabled; */
+	ret = wpa_driver_tista_set_auth_param(drv, IW_AUTH_DROP_UNENCRYPTED,
+					      enabled);
+	return ret;
+}
+
+static int wpa_driver_tista_pmksa(struct wpa_driver_ti_data *drv,
+				 u32 cmd, const u8 *bssid, const u8 *pmkid)
+{
+	struct iwreq    iwr;
+	struct iw_pmksa pmksa;
+	int             ret = 0;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	os_memset(&pmksa, 0, sizeof(pmksa));
+	pmksa.cmd = cmd;
+	pmksa.bssid.sa_family = ARPHRD_ETHER;
+	if (bssid)
+		os_memcpy(pmksa.bssid.sa_data, bssid, ETH_ALEN);
+	if (pmkid) {
+		os_memcpy(pmksa.pmkid, pmkid, IW_PMKID_LEN);
+		wpa_printf(MSG_DEBUG, "pmkid %s", pmkid);
+	}
+	iwr.u.data.pointer = (caddr_t)&pmksa;
+	iwr.u.data.length = sizeof(pmksa);
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWPMKSA, &iwr) < 0) {
+		if (errno != EOPNOTSUPP)
+			perror("ioctl[SIOCSIWPMKSA]");
+		ret = -1;
+	}
+	return ret;
+}
+
+static int wpa_driver_tista_add_pmkid(void *priv, const u8 *bssid,
+				     const u8 *pmkid)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+	TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+	ret = wpa_driver_tista_pmksa(drv, IW_PMKSA_ADD, bssid, pmkid);
+	return ret;
+}
+
+static int wpa_driver_tista_remove_pmkid(void *priv, const u8 *bssid,
+		 			const u8 *pmkid)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+	TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+	ret = wpa_driver_tista_pmksa(drv, IW_PMKSA_REMOVE, bssid, pmkid);
+	return ret;
+}
+
+static int wpa_driver_tista_flush_pmkid(void *priv)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+	TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+	ret = wpa_driver_tista_pmksa(drv, IW_PMKSA_FLUSH, NULL, NULL);
+	return ret;
+}
+
+static int wpa_driver_tista_mlme(struct wpa_driver_ti_data *drv,
+				const u8 *addr, int cmd, int reason_code)
+{
+	struct iwreq   iwr;
+	struct iw_mlme mlme;
+	int            ret = 0;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	os_memset(&mlme, 0, sizeof(mlme));
+	mlme.cmd = cmd;
+	mlme.reason_code = reason_code;
+	mlme.addr.sa_family = ARPHRD_ETHER;
+	os_memcpy(mlme.addr.sa_data, addr, ETH_ALEN);
+	iwr.u.data.pointer = (caddr_t) &mlme;
+	iwr.u.data.length = sizeof(mlme);
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWMLME, &iwr) < 0) {
+		perror("ioctl[SIOCSIWMLME]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int wpa_driver_tista_deauthenticate(void *priv, const u8 *addr,
+					  int reason_code)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+        TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+	ret = wpa_driver_tista_mlme(drv, addr, IW_MLME_DEAUTH, reason_code);
+	return ret;
+}
+
+
+static int wpa_driver_tista_disassociate(void *priv, const u8 *addr,
+					int reason_code)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+        TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+	ret = wpa_driver_tista_mlme(drv, addr, IW_MLME_DISASSOC, reason_code);
+	return ret;
+}
+
+static int wpa_driver_tista_set_key_ext(void *priv, wpa_alg alg,
+				       const u8 *addr, int key_idx,
+				       int set_tx, const u8 *seq,
+				       size_t seq_len,
+				       const u8 *key, size_t key_len)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	struct iwreq iwr;
+	int          ret = 0;
+	struct iw_encode_ext *ext;
+
+	if (seq_len > IW_ENCODE_SEQ_MAX_SIZE) {
+		wpa_printf(MSG_DEBUG, "%s: Invalid seq_len %lu",
+			   __FUNCTION__, (unsigned long) seq_len);
+		return -1;
+	}
+
+	ext = os_zalloc(sizeof(*ext) + key_len);
+	if (ext == NULL)
+		return -1;
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.encoding.flags = key_idx + 1;
+	iwr.u.encoding.flags |= IW_ENCODE_TEMP;
+	if (alg == WPA_ALG_NONE)
+		iwr.u.encoding.flags |= IW_ENCODE_DISABLED;
+	iwr.u.encoding.pointer = (caddr_t) ext;
+	iwr.u.encoding.length = sizeof(*ext) + key_len;
+
+	if (addr == NULL ||
+	    os_memcmp(addr, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) == 0)
+		ext->ext_flags |= IW_ENCODE_EXT_GROUP_KEY;
+	if (set_tx)
+		ext->ext_flags |= IW_ENCODE_EXT_SET_TX_KEY;
+
+	ext->addr.sa_family = ARPHRD_ETHER;
+	if (addr)
+		os_memcpy(ext->addr.sa_data, addr, ETH_ALEN);
+	else
+		os_memset(ext->addr.sa_data, 0xff, ETH_ALEN);
+	if (key && key_len) {
+		os_memcpy(ext + 1, key, key_len);
+		ext->key_len = key_len;
+	}
+	switch (alg) {
+	case WPA_ALG_NONE:
+		ext->alg = IW_ENCODE_ALG_NONE;
+		break;
+	case WPA_ALG_WEP:
+		ext->alg = IW_ENCODE_ALG_WEP;
+		break;
+	case WPA_ALG_TKIP:
+		ext->alg = IW_ENCODE_ALG_TKIP;
+		break;
+	case WPA_ALG_CCMP:
+		ext->alg = IW_ENCODE_ALG_CCMP;
+		break;
+	case WPA_ALG_PMK:
+		ext->alg = IW_ENCODE_ALG_PMK;
+		break;
+#ifdef CONFIG_IEEE80211W
+	case WPA_ALG_IGTK:
+		ext->alg = IW_ENCODE_ALG_AES_CMAC;
+		break;
+#endif /* CONFIG_IEEE80211W */
+	default:
+		wpa_printf(MSG_DEBUG, "%s: Unknown algorithm %d",
+			   __FUNCTION__, alg);
+		os_free(ext);
+		return -1;
+	}
+
+	if (seq && seq_len) {
+		ext->ext_flags |= IW_ENCODE_EXT_RX_SEQ_VALID;
+		os_memcpy(ext->rx_seq, seq, seq_len);
+	}
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWENCODEEXT, &iwr) < 0) {
+		ret = errno == EOPNOTSUPP ? -2 : -1;
+		if (errno == ENODEV) {
+			/*
+			 * ndiswrapper seems to be returning incorrect error
+			 * code.. */
+			ret = -2;
+		}
+
+		perror("ioctl[SIOCSIWENCODEEXT]");
+	}
+
+	os_free(ext);
+	return ret;
+}
+
+/**
+ * wpa_driver_tista_set_key - Configure encryption key
+ * @priv: Pointer to driver data
+ * @priv: Private driver interface data
+ * @alg: Encryption algorithm (%WPA_ALG_NONE, %WPA_ALG_WEP,
+ *	%WPA_ALG_TKIP, %WPA_ALG_CCMP); %WPA_ALG_NONE clears the key.
+ * @addr: Address of the peer STA or ff:ff:ff:ff:ff:ff for
+ *	broadcast/default keys
+ * @key_idx: key index (0..3), usually 0 for unicast keys
+ * @set_tx: Configure this key as the default Tx key (only used when
+ *	driver does not support separate unicast/individual key
+ * @seq: Sequence number/packet number, seq_len octets, the next
+ *	packet number to be used for in replay protection; configured
+ *	for Rx keys (in most cases, this is only used with broadcast
+ *	keys and set to zero for unicast keys)
+ * @seq_len: Length of the seq, depends on the algorithm:
+ *	TKIP: 6 octets, CCMP: 6 octets
+ * @key: Key buffer; TKIP: 16-byte temporal key, 8-byte Tx Mic key,
+ *	8-byte Rx Mic Key
+ * @key_len: Length of the key buffer in octets (WEP: 5 or 13,
+ *	TKIP: 32, CCMP: 16)
+ * Returns: 0 on success, -1 on failure
+ *
+ * This function uses SIOCSIWENCODEEXT by default, but tries to use
+ * SIOCSIWENCODE if the extended ioctl fails when configuring a WEP key.
+ */
+static int wpa_driver_tista_set_key(void *priv, wpa_alg alg,
+			    const u8 *addr, int key_idx,
+			    int set_tx, const u8 *seq, size_t seq_len,
+			    const u8 *key, size_t key_len)
+{
+	struct wpa_driver_ti_data *drv = priv;
+    struct iwreq iwr;
+    int          ret = 0;
+
+	wpa_printf(MSG_DEBUG, "%s", __func__);
+	TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+
+    wpa_printf(MSG_DEBUG, "%s: alg=%d key_idx=%d set_tx=%d seq_len=%lu "
+		   "key_len=%lu",
+		   __FUNCTION__, alg, key_idx, set_tx,
+		   (unsigned long) seq_len, (unsigned long) key_len);
+
+	ret = wpa_driver_tista_set_key_ext(drv, alg, addr, key_idx, set_tx,
+					  seq, seq_len, key, key_len);
+	if (ret == 0)
+		return 0;
+
+	if (ret == -2 &&
+	    (alg == WPA_ALG_NONE || alg == WPA_ALG_WEP)) {
+		wpa_printf(MSG_DEBUG, "Driver did not support "
+			   "SIOCSIWENCODEEXT, trying SIOCSIWENCODE");
+		ret = 0;
+	} else {
+		wpa_printf(MSG_DEBUG, "Driver did not support "
+			   "SIOCSIWENCODEEXT");
+		return ret;
+	}
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.encoding.flags = key_idx + 1;
+	iwr.u.encoding.flags |= IW_ENCODE_TEMP;
+	if (alg == WPA_ALG_NONE)
+		iwr.u.encoding.flags |= IW_ENCODE_DISABLED;
+	iwr.u.encoding.pointer = (caddr_t) key;
+	iwr.u.encoding.length = key_len;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWENCODE, &iwr) < 0) {
+		perror("ioctl[SIOCSIWENCODE]");
+		ret = -1;
+	}
+
+	if (set_tx && alg != WPA_ALG_NONE) {
+		os_memset(&iwr, 0, sizeof(iwr));
+		os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+		iwr.u.encoding.flags = key_idx + 1;
+		iwr.u.encoding.flags |= IW_ENCODE_TEMP;
+		iwr.u.encoding.pointer = (caddr_t) NULL;
+		iwr.u.encoding.length = 0;
+		if (ioctl(drv->ioctl_sock, SIOCSIWENCODE, &iwr) < 0) {
+			perror("ioctl[SIOCSIWENCODE] (set_tx)");
+			ret = -1;
+		}
+	}
+	return ret;
+}
+
+
+static int wpa_driver_tista_set_gen_ie(void *priv, const u8 *ie, size_t ie_len)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	struct iwreq iwr;
+	int          ret = 0;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.data.pointer = (caddr_t)ie;
+	iwr.u.data.length = ie_len;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWGENIE, &iwr) < 0) {
+		perror("ioctl[SIOCSIWGENIE]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+static struct wpa_scan_results *wpa_driver_tista_get_scan_results(void *priv)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	struct wpa_scan_results   *res;
+	struct wpa_scan_res       **tmp;
+	unsigned                  ap_num;
+
+	TI_CHECK_DRIVER( drv->driver_is_loaded, NULL );
+	res = wpa_driver_tista_get_scan_results_internal(drv);
+	if (res == NULL) 
+    {
+		return NULL;
+	}
+
+	wpa_printf(MSG_DEBUG, "Actual APs number %d", res->num);
+	ap_num = (unsigned)scan_count(drv) + res->num;
+	tmp = os_realloc(res->res, ap_num * sizeof(struct wpa_scan_res *));
+	if (tmp == NULL)
+		return res;
+	res->num = scan_merge(drv, tmp, drv->force_merge_flag, res->num, ap_num);
+	wpa_printf(MSG_DEBUG, "After merge, APs number %d", res->num);
+	tmp = os_realloc(tmp, res->num * sizeof(struct wpa_scan_res *));
+	res->res = tmp;
+	return res;
+}
+
+int wpa_driver_tista_set_mode(void *priv, int mode)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	int ret;
+
+	wpa_printf(MSG_DEBUG, "%s", __func__);
+	TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+	ret = wpa_driver_tista_set_network_mode(drv, mode);
+	return ret;
+}
+#else
+/*-----------------------------------------------------------------------------
+Compare function for sorting scan results. Return >0 if @b is considered better.
+-----------------------------------------------------------------------------*/
+static int wpa_driver_tista_scan_result_compare(const void *a, const void *b)
+{
+	const struct wpa_scan_result *wa = a;
+	const struct wpa_scan_result *wb = b;
+
+	return( wb->level - wa->level );
+}
+
+static int wpa_driver_tista_get_scan_results(void *priv,
+					      struct wpa_scan_result *results,
+					      size_t max_size)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	int ap_num = 0;
+
+        TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+	ap_num = wpa_driver_tista_get_scan_results_internal(drv, results, max_size);
+	wpa_printf(MSG_DEBUG, "Actual APs number %d", ap_num);
+
+	if (ap_num < 0)
+		return -1;
+
+	/* Merge new results with previous */
+        ap_num = scan_merge(drv, results, drv->force_merge_flag, ap_num, max_size);
+	wpa_printf(MSG_DEBUG, "After merge, APs number %d", ap_num);
+	qsort(results, ap_num, sizeof(struct wpa_scan_result),
+		wpa_driver_tista_scan_result_compare);
+	return ap_num;
+}
+#endif
+
+
+static void wpa_driver_tista_get_scan_mode(struct iw_event *iwe,
+			       struct wpa_scan_data *res)
+{
+	if (iwe->u.mode == IW_MODE_ADHOC)
+		res->res.caps |= IEEE80211_CAP_IBSS;
+	else if (iwe->u.mode == IW_MODE_MASTER || iwe->u.mode == IW_MODE_INFRA)
+		res->res.caps |= IEEE80211_CAP_ESS;
+}
+
+
+static void wpa_driver_tista_get_scan_ssid(struct iw_event *iwe,
+			       struct wpa_scan_data *res, char *custom,
+			       char *end)
+{
+	int ssid_len = iwe->u.essid.length;
+	if (custom + ssid_len > end)
+		return;
+	if (iwe->u.essid.flags &&
+	    ssid_len > 0 &&
+	    ssid_len <= IW_ESSID_MAX_SIZE) {
+		os_memcpy(res->ssid, custom, ssid_len);
+		res->ssid_len = ssid_len;
+	}
+}
+
+
+static void wpa_driver_tista_get_scan_freq(struct iw_event *iwe,
+			       struct wpa_scan_data *res)
+{
+	int divi = 1000000, i;
+
+	if (iwe->u.freq.e == 0) {
+		/*
+		 * Some drivers do not report frequency, but a channel.
+		 * Try to map this to frequency by assuming they are using
+		 * IEEE 802.11b/g.  But don't overwrite a previously parsed
+		 * frequency if the driver sends both frequency and channel,
+		 * since the driver may be sending an A-band channel that we
+		 * don't handle here.
+		 */
+
+		if (res->res.freq)
+			return;
+
+		if (iwe->u.freq.m >= 1 && iwe->u.freq.m <= 13) {
+			res->res.freq = 2407 + 5 * iwe->u.freq.m;
+			return;
+		} else if (iwe->u.freq.m == 14) {
+			res->res.freq = 2484;
+			return;
+		}
+	}
+
+	if (iwe->u.freq.e > 6) {
+		wpa_printf(MSG_DEBUG, "Invalid freq in scan results (BSSID="
+			   MACSTR " m=%d e=%d)",
+			   MAC2STR(res->res.bssid), iwe->u.freq.m,
+			   iwe->u.freq.e);
+		return;
+	}
+
+	for (i = 0; i < iwe->u.freq.e; i++)
+		divi /= 10;
+	res->res.freq = iwe->u.freq.m / divi;
+}
+
+
+static void wpa_driver_tista_get_scan_qual(struct iw_event *iwe,
+			       struct wpa_scan_data *res)
+{
+	res->res.qual  = iwe->u.qual.qual;
+	res->res.noise = iwe->u.qual.noise;
+	res->res.level = iwe->u.qual.level;
+}
+
+
+static void wpa_driver_tista_get_scan_encode(struct iw_event *iwe,
+				 struct wpa_scan_data *res)
+{
+	if (!(iwe->u.data.flags & IW_ENCODE_DISABLED))
+		res->res.caps |= IEEE80211_CAP_PRIVACY;
+}
+
+
+static void wpa_driver_tista_get_scan_rate(struct iw_event *iwe,
+			       struct wpa_scan_data *res, char *pos,
+			       char *end)
+{
+	int             maxrate;
+	char            *custom = pos + IW_EV_LCP_LEN;
+	struct iw_param p;
+	size_t          clen;
+
+	clen = iwe->len;
+	if (custom + clen > end)
+		return;
+	maxrate = 0;
+	while (((ssize_t) clen) >= (ssize_t) sizeof(struct iw_param)) {
+		/* Note: may be misaligned, make a local, aligned copy */
+		os_memcpy(&p, custom, sizeof(struct iw_param));
+		if (p.value > maxrate)
+			maxrate = p.value;
+		clen -= sizeof(struct iw_param);
+		custom += sizeof(struct iw_param);
+	}
+
+	/* Convert the maxrate from WE-style (b/s units) to
+	 * 802.11 rates (500000 b/s units).
+	 */
+	res->maxrate = maxrate / 500000;
+}
+
+
+static void wpa_driver_tista_get_scan_iwevgenie(struct iw_event *iwe,
+				    struct wpa_scan_data *res, char *custom,
+				    char *end)
+{
+	char *genie, *gpos, *gend;
+	u8 *tmp;
+
+	if (iwe->u.data.length == 0)
+		return;
+
+	gpos = genie = custom;
+	gend = genie + iwe->u.data.length;
+	if (gend > end) {
+		wpa_printf(MSG_INFO, "IWEVGENIE overflow");
+		return;
+	}
+
+	tmp = os_realloc(res->ie, res->ie_len + gend - gpos);
+	if (tmp == NULL)
+		return;
+	os_memcpy(tmp + res->ie_len, gpos, gend - gpos);
+	res->ie = tmp;
+	res->ie_len += gend - gpos;
+}
+
+
+static void wpa_driver_tista_get_scan_custom(struct iw_event *iwe,
+				 struct wpa_scan_data *res, char *custom,
+				 char *end)
+{
+	size_t  clen;
+	u8      *tmp;
+
+	clen = iwe->u.data.length;
+	if (custom + clen > end)
+		return;
+
+	if (clen > 7 && os_strncmp(custom, "wpa_ie=", 7) == 0) {
+		char *spos;
+		int bytes;
+		spos = custom + 7;
+		bytes = custom + clen - spos;
+		if (bytes & 1 || bytes == 0)
+			return;
+		bytes /= 2;
+		tmp = os_realloc(res->ie, res->ie_len + bytes);
+		if (tmp == NULL)
+			return;
+		hexstr2bin(spos, tmp + res->ie_len, bytes);
+		res->ie = tmp;
+		res->ie_len += bytes;
+	} else if (clen > 7 && os_strncmp(custom, "rsn_ie=", 7) == 0) {
+		char *spos;
+		int bytes;
+		spos = custom + 7;
+		bytes = custom + clen - spos;
+		if (bytes & 1 || bytes == 0)
+			return;
+		bytes /= 2;
+		tmp = os_realloc(res->ie, res->ie_len + bytes);
+		if (tmp == NULL)
+			return;
+		hexstr2bin(spos, tmp + res->ie_len, bytes);
+		res->ie = tmp;
+		res->ie_len += bytes;
+	} else if (clen > 4 && os_strncmp(custom, "tsf=", 4) == 0) {
+		char *spos;
+		int bytes;
+		u8 bin[8];
+		spos = custom + 4;
+		bytes = custom + clen - spos;
+		if (bytes != 16) {
+			wpa_printf(MSG_INFO, "Invalid TSF length (%d)", bytes);
+			return;
+		}
+		bytes /= 2;
+		hexstr2bin(spos, bin, bytes);
+		res->res.tsf += WPA_GET_BE64(bin);
+	}
+}
+
+
+static int wpa_driver_tista_19_iw_point(struct wpa_driver_ti_data *drv, u16 cmd)
+{
+	return drv->we_version_compiled > 18 &&
+		(cmd == SIOCGIWESSID || cmd == SIOCGIWENCODE ||
+		 cmd == IWEVGENIE || cmd == IWEVCUSTOM);
+}
+
+static void wpa_driver_tista_add_scan_entry(struct wpa_scan_results *res,
+					   struct wpa_scan_data *data)
+{
+	struct wpa_scan_res **tmp;
+	struct wpa_scan_res *r;
+	size_t extra_len;
+	u8 *pos, *end, *ssid_ie = NULL, *rate_ie = NULL;
+
+	/* Figure out whether we need to fake any IEs */
+	pos = data->ie;
+	end = pos + data->ie_len;
+	while (pos && pos + 1 < end) {
+		if (pos + 2 + pos[1] > end)
+			break;
+		if (pos[0] == WLAN_EID_SSID)
+			ssid_ie = pos;
+		else if (pos[0] == WLAN_EID_SUPP_RATES)
+			rate_ie = pos;
+		else if (pos[0] == WLAN_EID_EXT_SUPP_RATES)
+			rate_ie = pos;
+		pos += 2 + pos[1];
+	}
+
+	extra_len = 0;
+	if (ssid_ie == NULL)
+		extra_len += 2 + data->ssid_len;
+	if (rate_ie == NULL && data->maxrate)
+		extra_len += 3;
+
+	r = os_zalloc(sizeof(*r) + extra_len + data->ie_len);
+	if (r == NULL)
+		return;
+	os_memcpy(r, &data->res, sizeof(*r));
+	r->ie_len = extra_len + data->ie_len;
+	pos = (u8 *) (r + 1);
+	if (ssid_ie == NULL) {
+		/*
+		 * Generate a fake SSID IE since the driver did not report
+		 * a full IE list.
+		 */
+		*pos++ = WLAN_EID_SSID;
+		*pos++ = data->ssid_len;
+		os_memcpy(pos, data->ssid, data->ssid_len);
+		pos += data->ssid_len;
+	}
+	if (rate_ie == NULL && data->maxrate) {
+		/*
+		 * Generate a fake Supported Rates IE since the driver did not
+		 * report a full IE list.
+		 */
+		*pos++ = WLAN_EID_SUPP_RATES;
+		*pos++ = 1;
+		*pos++ = data->maxrate;
+	}
+	if (data->ie)
+		os_memcpy(pos, data->ie, data->ie_len);
+
+	tmp = os_realloc(res->res,
+			 (res->num + 1) * sizeof(struct wpa_scan_res *));
+	if (tmp == NULL) {
+		os_free(r);
+		return;
+	}
+	tmp[res->num++] = r;
+	res->res = tmp;
+}
+
+static u8 * wpa_driver_tista_giwscan(struct wpa_driver_ti_data *drv,
+				    size_t *len, u16* flags)
+{
+	struct iwreq    iwr;
+	u8              *res_buf;
+	size_t          res_buf_len;
+
+	res_buf_len = IW_SCAN_MAX_DATA;
+	for (;;) {
+		res_buf = os_malloc(res_buf_len);
+		if (res_buf == NULL)
+			return NULL;
+		os_memset(&iwr, 0, sizeof(iwr));
+		os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+		iwr.u.data.pointer = res_buf;
+		iwr.u.data.length = res_buf_len;
+        iwr.u.data.flags = *flags;
+
+		if (ioctl(drv->ioctl_sock, SIOCGIWSCAN, &iwr) == 0)
+			break;
+
+		if (errno == E2BIG && res_buf_len < 65535) {
+			os_free(res_buf);
+			res_buf = NULL;
+			res_buf_len *= 2;
+			if (res_buf_len > 65535)
+				res_buf_len = 65535; /* 16-bit length field */
+			wpa_printf(MSG_DEBUG, "Scan results did not fit - "
+				   "trying larger buffer (%lu bytes)",
+				   (unsigned long) res_buf_len);
+		} else {
+			perror("ioctl[SIOCGIWSCAN]");
+			os_free(res_buf);
+			return NULL;
+		}
+	}
+
+	if (iwr.u.data.length > res_buf_len) {
+		os_free(res_buf);
+		return NULL;
+	}
+	*len = iwr.u.data.length;
+    *flags = iwr.u.data.flags;
+
+	return res_buf;
+}
+
+static int wpa_driver_tista_get_range(void *priv)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	struct iw_range *range;
+	struct iwreq iwr;
+	int    minlen;
+	size_t buflen;
+
+	/*
+	 * Use larger buffer than struct iw_range in order to allow the
+	 * structure to grow in the future.
+	 */
+	buflen = sizeof(struct iw_range) + 500;
+	range = os_zalloc(buflen);
+	if (range == NULL)
+		return -1;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.data.pointer = (caddr_t) range;
+	iwr.u.data.length = buflen;
+
+	minlen = ((char *) &range->enc_capa) - (char *) range +
+		sizeof(range->enc_capa);
+
+	if (ioctl(drv->ioctl_sock, SIOCGIWRANGE, &iwr) < 0) {
+		perror("ioctl[SIOCGIWRANGE]");
+		os_free(range);
+		return -1;
+	} else if (iwr.u.data.length >= minlen &&
+		   range->we_version_compiled >= 18) {
+		wpa_printf(MSG_DEBUG, "SIOCGIWRANGE: WE(compiled)=%d "
+			   "WE(source)=%d enc_capa=0x%x",
+			   range->we_version_compiled,
+			   range->we_version_source,
+			   range->enc_capa);
+		drv->has_capability = 1;
+		drv->we_version_compiled = range->we_version_compiled;
+		if (range->enc_capa & IW_ENC_CAPA_WPA) {
+			drv->capa.key_mgmt |= WPA_DRIVER_CAPA_KEY_MGMT_WPA |
+				WPA_DRIVER_CAPA_KEY_MGMT_WPA_PSK;
+		}
+		if (range->enc_capa & IW_ENC_CAPA_WPA2) {
+			drv->capa.key_mgmt |= WPA_DRIVER_CAPA_KEY_MGMT_WPA2 |
+				WPA_DRIVER_CAPA_KEY_MGMT_WPA2_PSK;
+		}
+		drv->capa.enc |= WPA_DRIVER_CAPA_ENC_WEP40 |
+			WPA_DRIVER_CAPA_ENC_WEP104;
+		if (range->enc_capa & IW_ENC_CAPA_CIPHER_TKIP)
+			drv->capa.enc |= WPA_DRIVER_CAPA_ENC_TKIP;
+		if (range->enc_capa & IW_ENC_CAPA_CIPHER_CCMP)
+			drv->capa.enc |= WPA_DRIVER_CAPA_ENC_CCMP;
+		if (range->enc_capa & IW_ENC_CAPA_4WAY_HANDSHAKE)
+			drv->capa.flags |= WPA_DRIVER_FLAGS_4WAY_HANDSHAKE;
+		drv->capa.auth = WPA_DRIVER_AUTH_OPEN |
+			WPA_DRIVER_AUTH_SHARED |
+			WPA_DRIVER_AUTH_LEAP;
+
+		wpa_printf(MSG_DEBUG, "  capabilities: key_mgmt 0x%x enc 0x%x "
+			   "flags 0x%x",
+			   drv->capa.key_mgmt, drv->capa.enc, drv->capa.flags);
+	} else {
+		wpa_printf(MSG_DEBUG, "SIOCGIWRANGE: too old (short) data - "
+			   "assuming WPA is not supported");
+	}
+
+	os_free(range);
+	return 0;
+}
+
+
+static int wpa_driver_tista_associate(void *priv,
+			  struct wpa_driver_associate_params *params)
+{
+
+    struct wpa_driver_ti_data *drv = priv;
+	int allow_unencrypted_eapol;
+	int value, flags, ret = 0;
+
+	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
+
+    TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );
+
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+#ifdef ANDROID
+	drv->skip_disconnect = 0;
+#endif
+#endif
+
+	if (wpa_driver_tista_get_ifflags(drv, &flags) == 0) 
+    {
+		if (!(flags & IFF_UP)) 
+        {
+			wpa_driver_tista_set_ifflags(drv, flags | IFF_UP);
+		}
+	}
+
+#if 0
+	if (!params->bssid)
+    {
+        wpa_driver_tista_set_bssid(drv, NULL);
+    }
+		
+#endif
+
+#ifdef WPA_SUPPLICANT_VER_0_5_X
+	/* Set driver network mode (Adhoc/Infrastructure) according to supplied parameters */
+	wpa_driver_tista_set_mode(drv, params->mode);
+#endif
+	wpa_driver_tista_set_gen_ie(drv, params->wpa_ie, params->wpa_ie_len);
+
+	if (params->wpa_ie == NULL || params->wpa_ie_len == 0)
+		value = IW_AUTH_WPA_VERSION_DISABLED;
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+	else if (params->wpa_ie[0] == WLAN_EID_RSN)
+#else
+	else if (params->wpa_ie[0] == RSN_INFO_ELEM)
+#endif
+		value = IW_AUTH_WPA_VERSION_WPA2;
+#ifdef CONFIG_WPS
+	else if (params->key_mgmt_suite == KEY_MGMT_WPS)
+		value = IW_AUTH_WPA_VERSION_DISABLED;
+#endif
+	else
+		value = IW_AUTH_WPA_VERSION_WPA;
+	wpa_driver_tista_set_auth_param(drv, IW_AUTH_WPA_VERSION, value);
+	value = wpa_driver_tista_cipher2wext(params->pairwise_suite);
+	wpa_driver_tista_set_auth_param(drv, IW_AUTH_CIPHER_PAIRWISE, value);
+	value = wpa_driver_tista_cipher2wext(params->group_suite);
+	wpa_driver_tista_set_auth_param(drv, IW_AUTH_CIPHER_GROUP, value);
+	value = wpa_driver_tista_keymgmt2wext(params->key_mgmt_suite);
+	wpa_driver_tista_set_auth_param(drv, IW_AUTH_KEY_MGMT, value);
+	value = params->key_mgmt_suite != KEY_MGMT_NONE ||
+		params->pairwise_suite != CIPHER_NONE ||
+		params->group_suite != CIPHER_NONE ||
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+		(params->wpa_ie_len && (params->key_mgmt_suite != KEY_MGMT_WPS));
+#else
+		params->wpa_ie_len;
+#endif
+	wpa_driver_tista_set_auth_param(drv, IW_AUTH_PRIVACY_INVOKED, value);
+
+	/* Allow unencrypted EAPOL messages even if pairwise keys are set when
+	 * not using WPA. IEEE 802.1X specifies that these frames are not
+	 * encrypted, but WPA encrypts them when pairwise keys are in use. */
+	if (params->key_mgmt_suite == KEY_MGMT_802_1X ||
+	    params->key_mgmt_suite == KEY_MGMT_PSK)
+		allow_unencrypted_eapol = 0;
+	else
+		allow_unencrypted_eapol = 1;
+	wpa_driver_tista_set_auth_param(drv,
+					   IW_AUTH_RX_UNENCRYPTED_EAPOL,
+					   allow_unencrypted_eapol);
+
+	if (params->freq)
+		wpa_driver_tista_set_freq(drv, params->freq);
+
+	if (params->bssid) {
+		wpa_printf(MSG_DEBUG, "wpa_driver_tista_associate: BSSID=" MACSTR,
+			            MAC2STR(params->bssid));
+		/* if there is bssid -> set it */
+		if (os_memcmp(params->bssid, "\x00\x00\x00\x00\x00\x00", ETH_ALEN) != 0) {
+			wpa_driver_tista_set_bssid(drv, params->bssid);
+		}
+	}
+	ret = wpa_driver_tista_set_ssid(drv, params->ssid, params->ssid_len);
+	return ret;
+}
+
+static int wpa_driver_tista_set_operstate(void *priv, int state)
+{
+	struct wpa_driver_ti_data *drv = priv;
+    drv->operstate = state;
+
+	wpa_printf(MSG_DEBUG, "%s: operstate %d (%s)",
+		   __func__, /*drv->operstate,*/ state, state ? "UP" : "DORMANT");
+        TI_CHECK_DRIVER( drv->driver_is_loaded, -1 );		   
+
+    wpa_driver_tista_private_send(priv, RSN_PORT_STATUS_PARAM, &state, sizeof(state), NULL, 0);
+
+    return wpa_driver_tista_send_oper_ifla(
+		drv, -1, state ? IF_OPER_UP : IF_OPER_DORMANT);
+}
+
+/**
+ * wpa_driver_tista_set_bssid - Set BSSID, SIOCSIWAP
+ * @priv: Pointer to driver data
+ * @bssid: BSSID
+ * Returns: 0 on success, -1 on failure
+ */
+static int wpa_driver_tista_set_bssid(void *priv, const u8 *bssid)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	struct iwreq iwr;
+	int ret = 0;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.ap_addr.sa_family = ARPHRD_ETHER;
+	if (bssid)
+		os_memcpy(iwr.u.ap_addr.sa_data, bssid, ETH_ALEN);
+	else
+		os_memset(iwr.u.ap_addr.sa_data, 0, ETH_ALEN);
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWAP, &iwr) < 0) {
+		perror("ioctl[SIOCSIWAP]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+static int wpa_driver_tista_get_ifflags_ifname(struct wpa_driver_ti_data *drv,
+					      const char *ifname, int *flags)
+{
+	struct ifreq ifr;
+
+	os_memset(&ifr, 0, sizeof(ifr));
+	os_strlcpy(ifr.ifr_name, ifname, IFNAMSIZ);
+	if (ioctl(drv->ioctl_sock, SIOCGIFFLAGS, (caddr_t) &ifr) < 0) {
+		perror("ioctl[SIOCGIFFLAGS]");
+		return -1;
+	}
+	*flags = ifr.ifr_flags & 0xffff;
+	return 0;
+}
+
+/**
+ * wpa_driver_tista_get_ifflags - Get interface flags (SIOCGIFFLAGS)
+ * @drv: driver private data
+ * @flags: Pointer to returned flags value
+ * Returns: 0 on success, -1 on failure
+ */
+static int wpa_driver_tista_get_ifflags(struct wpa_driver_ti_data *drv, int *flags)
+{
+	return wpa_driver_tista_get_ifflags_ifname(drv, drv->ifname, flags);
+}
+
+static int wpa_driver_tista_set_ifflags_ifname(struct wpa_driver_ti_data *drv,
+					      const char *ifname, int flags)
+{
+	struct ifreq ifr;
+
+	os_memset(&ifr, 0, sizeof(ifr));
+	os_strlcpy(ifr.ifr_name, ifname, IFNAMSIZ);
+	ifr.ifr_flags = flags & 0xffff;
+	if (ioctl(drv->ioctl_sock, SIOCSIFFLAGS, (caddr_t) &ifr) < 0) {
+		perror("SIOCSIFFLAGS");
+		return -1;
+	}
+	return 0;
+}
+
+/**
+ * wpa_driver_tista_set_ifflags - Set interface flags (SIOCSIFFLAGS)
+ * @drv: driver private data
+ * @flags: New value for flags
+ * Returns: 0 on success, -1 on failure
+ */
+static int wpa_driver_tista_set_ifflags(struct wpa_driver_ti_data *drv, int flags)
+{
+	return wpa_driver_tista_set_ifflags_ifname(drv, drv->ifname, flags);
+}
+
+/**
+ * wpa_driver_tista_set_network_mode - Set wireless mode (infra/adhoc), SIOCSIWMODE
+ * @priv: Pointer to private driver data
+ * @mode: 0 = infra/BSS (associate with an AP), 1 = adhoc/IBSS
+ * Returns: 0 on success, -1 on failure
+ */
+static int wpa_driver_tista_set_network_mode(void *priv, int mode)
+{
+	struct wpa_driver_ti_data *drv      = priv;
+    struct wpa_supplicant     *wpa_s    = (struct wpa_supplicant *)(drv->ctx);
+    struct wpa_config         *wpa_conf = (struct wpa_config *)(wpa_s->conf); 
+	struct iwreq iwr;
+	int ret = -1, flags;
+	unsigned int new_mode = mode ? IW_MODE_ADHOC : IW_MODE_INFRA;
+
+
+    os_memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.mode = new_mode;
+
+    if (new_mode == IW_MODE_INFRA) 
+    {
+        wpa_conf->ap_scan = 1;
+    }
+    else if (new_mode == IW_MODE_ADHOC) 
+    {
+        wpa_conf->ap_scan = 2;
+    }
+    else
+    {
+        wpa_printf(MSG_ERROR,"wpa_driver_tista_set_network_mode: Unspecified mode");
+    }
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWMODE, &iwr) == 0) {
+		ret = 0;
+		goto done;
+	}
+
+	if (errno != EBUSY) {
+		perror("ioctl[SIOCSIWMODE]");
+		goto done;
+	}
+
+
+     
+
+	/* mac80211 doesn't allow mode changes while the device is up, so if
+	 * the device isn't in the mode we're about to change to, take device
+	 * down, try to set the mode again, and bring it back up.
+	 */
+	if (ioctl(drv->ioctl_sock, SIOCGIWMODE, &iwr) < 0) {
+		perror("ioctl[SIOCGIWMODE]");
+		goto done;
+	}
+
+	if (iwr.u.mode == new_mode) {
+		ret = 0;
+		goto done;
+	}
+
+	if (wpa_driver_tista_get_ifflags(drv, &flags) == 0) {
+		(void) wpa_driver_tista_set_ifflags(drv, flags & ~IFF_UP);
+
+		/* Try to set the mode again while the interface is down */
+		iwr.u.mode = new_mode;
+		if (ioctl(drv->ioctl_sock, SIOCSIWMODE, &iwr) < 0)
+			perror("ioctl[SIOCSIWMODE]");
+		else
+			ret = 0;
+
+		/* Ignore return value of get_ifflags to ensure that the device
+		 * is always up like it was before this function was called.
+		 */
+		(void) wpa_driver_tista_get_ifflags(drv, &flags);
+		(void) wpa_driver_tista_set_ifflags(drv, flags | IFF_UP);
+	}
+
+done:
+	return ret;
+}
+
+
+static int wpa_driver_tista_send_oper_ifla(struct wpa_driver_ti_data *drv,
+					  int linkmode, int operstate)
+{
+	struct {
+		struct nlmsghdr hdr;
+		struct ifinfomsg ifinfo;
+		char opts[16];
+	} req;
+	struct rtattr *rta;
+	static int nl_seq;
+	ssize_t ret;
+
+
+	os_memset(&req, 0, sizeof(req));
+
+	req.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(struct ifinfomsg));
+	req.hdr.nlmsg_type = RTM_SETLINK;
+	req.hdr.nlmsg_flags = NLM_F_REQUEST;
+	req.hdr.nlmsg_seq = ++nl_seq;
+	req.hdr.nlmsg_pid = 0;
+
+	req.ifinfo.ifi_family = AF_UNSPEC;
+	req.ifinfo.ifi_type = 0;
+	req.ifinfo.ifi_index = drv->ifindex;
+	req.ifinfo.ifi_flags = 0;
+	req.ifinfo.ifi_change = 0;
+
+	if (linkmode != -1) {
+		rta = aliasing_hide_typecast(
+			((char *) &req + NLMSG_ALIGN(req.hdr.nlmsg_len)),
+			struct rtattr);
+		rta->rta_type = IFLA_LINKMODE;
+		rta->rta_len = RTA_LENGTH(sizeof(char));
+		*((char *) RTA_DATA(rta)) = linkmode;
+		req.hdr.nlmsg_len = NLMSG_ALIGN(req.hdr.nlmsg_len) +
+			RTA_LENGTH(sizeof(char));
+	}
+	if (operstate != -1) {
+		rta = (struct rtattr *)
+			((char *) &req + NLMSG_ALIGN(req.hdr.nlmsg_len));
+		rta->rta_type = IFLA_OPERSTATE;
+		rta->rta_len = RTA_LENGTH(sizeof(char));
+		*((char *) RTA_DATA(rta)) = operstate;
+		req.hdr.nlmsg_len = NLMSG_ALIGN(req.hdr.nlmsg_len) +
+			RTA_LENGTH(sizeof(char));
+	}
+
+	wpa_printf(MSG_DEBUG, "Driver_ti: Operstate: linkmode=%d, operstate=%d",
+		   linkmode, operstate);
+
+
+	ret = send(drv->event_sock, &req, req.hdr.nlmsg_len, 0);
+	if (ret < 0) {
+		wpa_printf(MSG_DEBUG, "Driver_ti: Sending operstate IFLA failed: "
+			   "%s (assume operstate is not supported)",
+			   strerror(errno));
+	}
+
+	return ret < 0 ? -1 : 0;
+}
+
+static void wpa_driver_tista_event_receive(int sock, void *eloop_ctx,
+					  void *sock_ctx)
+{
+	char buf[8192];
+	int left;
+	struct sockaddr_nl from;
+	socklen_t fromlen;
+	struct nlmsghdr *h;
+	int max_events = 10;
+
+try_again:
+	fromlen = sizeof(from);
+	left = recvfrom(sock, buf, sizeof(buf), MSG_DONTWAIT,
+			(struct sockaddr *) &from, &fromlen);
+	if (left < 0) {
+		if (errno != EINTR && errno != EAGAIN)
+			perror("recvfrom(netlink)");
+		return;
+	}
+
+	h = (struct nlmsghdr *) buf;
+	while (left >= (int) sizeof(*h)) {
+		int len, plen;
+
+		len = h->nlmsg_len;
+		plen = len - sizeof(*h);
+		if (len > left || plen < 0) {
+			wpa_printf(MSG_DEBUG, "Malformed netlink message: "
+				   "len=%d left=%d plen=%d",
+				   len, left, plen);
+			break;
+		}
+
+		switch (h->nlmsg_type) {
+		case RTM_NEWLINK:
+			wpa_driver_tista_event_rtm_newlink(eloop_ctx, sock_ctx, h, plen);
+			break;
+		case RTM_DELLINK:
+			wpa_driver_tista_event_rtm_dellink(eloop_ctx, sock_ctx, h, plen);
+			break;
+		}
+
+		len = NLMSG_ALIGN(len);
+		left -= len;
+		h = (struct nlmsghdr *) ((char *) h + len);
+	}
+
+	if (left > 0) {
+		wpa_printf(MSG_DEBUG, "%d extra bytes in the end of netlink "
+			   "message", left);
+	}
+
+	if (--max_events > 0) {
+		/*
+		 * Try to receive all events in one eloop call in order to
+		 * limit race condition on cases where AssocInfo event, Assoc
+		 * event, and EAPOL frames are received more or less at the
+		 * same time. We want to process the event messages first
+		 * before starting EAPOL processing.
+		 */
+		goto try_again;
+	}
+}
+
+static void wpa_driver_tista_event_rtm_newlink(struct wpa_driver_ti_data *drv,
+					      void *ctx, struct nlmsghdr *h, size_t len)
+{
+	struct ifinfomsg *ifi;
+	int attrlen, nlmsg_len, rta_len;
+	struct rtattr * attr;
+
+	if (len < sizeof(*ifi))
+		return;
+
+	ifi = NLMSG_DATA(h);
+
+	if (!wpa_driver_tista_own_ifindex(drv, ifi->ifi_index, h)) {
+		wpa_printf(MSG_DEBUG, "Ignore event for foreign ifindex %d",
+			   ifi->ifi_index);
+		return;
+	}
+
+	wpa_printf(MSG_DEBUG, "RTM_NEWLINK: operstate=%d ifi_flags=0x%x "
+		   "(%s%s%s%s)",
+		   drv->operstate, ifi->ifi_flags,
+		   (ifi->ifi_flags & IFF_UP) ? "[UP]" : "",
+		   (ifi->ifi_flags & IFF_RUNNING) ? "[RUNNING]" : "",
+		   (ifi->ifi_flags & IFF_LOWER_UP) ? "[LOWER_UP]" : "",
+		   (ifi->ifi_flags & IFF_DORMANT) ? "[DORMANT]" : "");
+	/*
+	 * Some drivers send the association event before the operup event--in
+	 * this case, lifting operstate in wpa_driver_tista_set_operstate()
+	 * fails. This will hit us when wpa_supplicant does not need to do
+	 * IEEE 802.1X authentication
+	 */
+	if (drv->operstate == 1 &&
+	    (ifi->ifi_flags & (IFF_LOWER_UP | IFF_DORMANT)) == IFF_LOWER_UP &&
+	    !(ifi->ifi_flags & IFF_RUNNING))
+		wpa_driver_tista_send_oper_ifla(drv, -1, IF_OPER_UP);
+
+	nlmsg_len = NLMSG_ALIGN(sizeof(struct ifinfomsg));
+
+	attrlen = h->nlmsg_len - nlmsg_len;
+	if (attrlen < 0)
+		return;
+
+	attr = (struct rtattr *) (((char *) ifi) + nlmsg_len);
+
+	rta_len = RTA_ALIGN(sizeof(struct rtattr));
+	while (RTA_OK(attr, attrlen)) {
+		if (attr->rta_type == IFLA_WIRELESS) {
+			wpa_driver_tista_event_wireless(
+				drv, ctx, ((char *) attr) + rta_len,
+				attr->rta_len - rta_len);
+		} else if (attr->rta_type == IFLA_IFNAME) {
+			wpa_driver_tista_event_link(drv, ctx,
+						   ((char *) attr) + rta_len,
+						   attr->rta_len - rta_len, 0);
+		}
+		attr = RTA_NEXT(attr, attrlen);
+	}
+}
+
+static void wpa_driver_tista_event_link(struct wpa_driver_ti_data *drv,
+				       void *ctx, char *buf, size_t len, int del)
+{
+	union wpa_event_data event;
+
+	os_memset(&event, 0, sizeof(event));
+	if (len > sizeof(event.interface_status.ifname))
+		len = sizeof(event.interface_status.ifname) - 1;
+	os_memcpy(event.interface_status.ifname, buf, len);
+	event.interface_status.ievent = del ? EVENT_INTERFACE_REMOVED :
+		EVENT_INTERFACE_ADDED;
+
+	wpa_printf(MSG_DEBUG, "RTM_%sLINK, IFLA_IFNAME: Interface '%s' %s",
+		   del ? "DEL" : "NEW",
+		   event.interface_status.ifname,
+		   del ? "removed" : "added");
+
+	if (os_strcmp(drv->ifname, event.interface_status.ifname) == 0) {
+		if (del)
+			drv->if_removed = 1;
+		else
+			drv->if_removed = 0;
+	}
+
+	wpa_supplicant_event(ctx, EVENT_INTERFACE_STATUS, &event);
+}
+
+static void wpa_driver_tista_event_rtm_dellink(struct wpa_driver_ti_data *drv,
+					      void *ctx, struct nlmsghdr *h,
+					      size_t len)
+{
+	struct ifinfomsg *ifi;
+	int attrlen, nlmsg_len, rta_len;
+	struct rtattr * attr;
+
+	if (len < sizeof(*ifi))
+		return;
+
+	ifi = NLMSG_DATA(h);
+
+	nlmsg_len = NLMSG_ALIGN(sizeof(struct ifinfomsg));
+
+	attrlen = h->nlmsg_len - nlmsg_len;
+	if (attrlen < 0)
+		return;
+
+	attr = (struct rtattr *) (((char *) ifi) + nlmsg_len);
+
+	rta_len = RTA_ALIGN(sizeof(struct rtattr));
+	while (RTA_OK(attr, attrlen)) {
+		if (attr->rta_type == IFLA_IFNAME) {
+			wpa_driver_tista_event_link(drv,  ctx,
+						   ((char *) attr) + rta_len,
+						   attr->rta_len - rta_len, 1);
+		}
+		attr = RTA_NEXT(attr, attrlen);
+	}
+}
+
+static int wpa_driver_tista_alternative_ifindex(struct wpa_driver_ti_data *drv,
+					const char *ifname)
+{
+	if (ifname == NULL) {
+		drv->ifindex2 = -1;
+		return 0;
+	}
+
+	drv->ifindex2 = if_nametoindex(ifname);
+	if (drv->ifindex2 <= 0)
+		return -1;
+
+	wpa_printf(MSG_DEBUG, "Added alternative ifindex %d (%s) for "
+		   "wireless events", drv->ifindex2, ifname);
+
+	return 0;
+}
+
+static int wpa_driver_tista_own_ifindex(struct wpa_driver_ti_data *drv,
+				       int ifindex, struct nlmsghdr *h)
+{
+	if (drv->ifindex == ifindex || drv->ifindex2 == ifindex)
+		return 1;
+
+	if (drv->if_removed && wpa_driver_tista_own_ifname(drv, h)) {
+		drv->ifindex = if_nametoindex(drv->ifname);
+		wpa_printf(MSG_DEBUG, "Driver_ti: Update ifindex for a removed "
+			   "interface");
+		wpa_driver_tista_finish_drv_init(drv);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int wpa_driver_tista_own_ifname(struct wpa_driver_ti_data *drv,
+				      struct nlmsghdr *h)
+{
+	struct ifinfomsg *ifi;
+	int attrlen, nlmsg_len, rta_len;
+	struct rtattr *attr;
+
+	ifi = NLMSG_DATA(h);
+
+	nlmsg_len = NLMSG_ALIGN(sizeof(struct ifinfomsg));
+
+	attrlen = h->nlmsg_len - nlmsg_len;
+	if (attrlen < 0)
+		return 0;
+
+	attr = (struct rtattr *) (((char *) ifi) + nlmsg_len);
+
+	rta_len = RTA_ALIGN(sizeof(struct rtattr));
+	while (RTA_OK(attr, attrlen)) {
+		if (attr->rta_type == IFLA_IFNAME) {
+			if (os_strcmp(((char *) attr) + rta_len, drv->ifname)
+			    == 0)
+				return 1;
+			else
+				break;
+		}
+		attr = RTA_NEXT(attr, attrlen);
+	}
+
+	return 0;
+}
+
+static void wpa_driver_tista_event_wireless(struct wpa_driver_ti_data *drv,
+					   void *ctx, char *data, int len)
+{
+	struct iw_event iwe_buf, *iwe = &iwe_buf;
+	char   *pos, *end, *custom, *buf;
+
+	pos = data;
+	end = data + len;
+
+	while (pos + IW_EV_LCP_LEN <= end) {
+		/* Event data may be unaligned, so make a local, aligned copy
+		 * before processing. */
+		os_memcpy(&iwe_buf, pos, IW_EV_LCP_LEN);
+		wpa_printf(MSG_DEBUG, "Wireless event: cmd=0x%x len=%d",
+			   iwe->cmd, iwe->len);
+		if (iwe->len <= IW_EV_LCP_LEN)
+			return;
+
+		custom = pos + IW_EV_POINT_LEN;
+		if (drv->we_version_compiled > 18 &&
+		    (iwe->cmd == IWEVMICHAELMICFAILURE ||
+		     iwe->cmd == IWEVCUSTOM ||
+		     iwe->cmd == IWEVASSOCREQIE ||
+		     iwe->cmd == IWEVASSOCRESPIE ||
+		     iwe->cmd == IWEVPMKIDCAND )) {
+			/* WE-19 removed the pointer from struct iw_point */
+			char *dpos = (char *) &iwe_buf.u.data.length;
+			int dlen = dpos - (char *) &iwe_buf;
+			os_memcpy(dpos, pos + IW_EV_LCP_LEN,
+				  sizeof(struct iw_event) - dlen);
+        } else {
+			os_memcpy(&iwe_buf, pos, sizeof(struct iw_event));
+			custom += IW_EV_POINT_OFF;
+		}
+
+		switch (iwe->cmd) {
+		case SIOCGIWAP:
+			wpa_printf(MSG_DEBUG, "Wireless event: new AP: "
+				   MACSTR,
+				   MAC2STR((u8 *) iwe->u.ap_addr.sa_data));
+			if (is_zero_ether_addr(
+				    (const u8 *) iwe->u.ap_addr.sa_data) ||
+			    os_memcmp(iwe->u.ap_addr.sa_data,
+				      "\x44\x44\x44\x44\x44\x44", ETH_ALEN) ==
+			    0) {
+				os_free(drv->assoc_req_ies);
+				drv->assoc_req_ies = NULL;
+				os_free(drv->assoc_resp_ies);
+				drv->assoc_resp_ies = NULL;
+#ifdef ANDROID
+				if (!drv->skip_disconnect) {
+					drv->skip_disconnect = 1;
+#endif
+					wpa_supplicant_event(ctx, EVENT_DISASSOC,
+						     NULL);
+#ifdef ANDROID
+				}
+#endif
+			
+			} else {
+#ifdef ANDROID
+				drv->skip_disconnect = 0;
+#endif
+				wpa_driver_tista_event_assoc_ies(drv);
+				wpa_supplicant_event(ctx, EVENT_ASSOC, NULL);
+			}
+			break;
+		case IWEVMICHAELMICFAILURE:
+			if (custom + iwe->u.data.length > end) {
+				wpa_printf(MSG_DEBUG, "TISTA: Invalid "
+					   "IWEVMICHAELMICFAILURE length");
+				return;
+			}
+			wpa_driver_tista_event_wireless_michaelmicfailure(
+				ctx, custom, iwe->u.data.length);
+			break;
+        case IWEVCUSTOM:
+			if (custom + iwe->u.data.length > end) {
+				wpa_printf(MSG_DEBUG, "TISTA: Invalid "
+					   "IWEVCUSTOM length");
+				return;
+			}
+			buf = os_malloc(iwe->u.data.length + 1);
+			if (buf == NULL)
+				return;
+			os_memcpy(buf, custom, iwe->u.data.length);
+			buf[iwe->u.data.length] = '\0';
+			wpa_driver_tista_event_wireless_custom(ctx, drv, buf);
+			os_free(buf);
+			break;
+        case SIOCGIWSCAN:  /* scan complete */
+        { 
+            wpa_printf(MSG_DEBUG,"SIOCGIWSCAN received. Ignoring\n");
+            /* Scan complete is sent using CUSTOM event 
+               (in order to pass client id), and therefore taken
+               care of at IWEVCUSTOM */
+			break;
+        }
+		case IWEVASSOCREQIE:
+			if (custom + iwe->u.data.length > end) {
+				wpa_printf(MSG_DEBUG, "TISTA: Invalid "
+					   "IWEVASSOCREQIE length");
+				return;
+			}
+			wpa_driver_tista_event_wireless_assocreqie(
+				drv, custom, iwe->u.data.length);
+			break;
+		case IWEVASSOCRESPIE:
+			if (custom + iwe->u.data.length > end) {
+				wpa_printf(MSG_DEBUG, "TISTA: Invalid "
+					   "IWEVASSOCRESPIE length");
+				return;
+			}
+			wpa_driver_tista_event_wireless_assocrespie(
+				drv, custom, iwe->u.data.length);
+			break;
+		case IWEVPMKIDCAND:
+			if (custom + iwe->u.data.length > end) {
+				wpa_printf(MSG_DEBUG, "TISTA: Invalid "
+					   "IWEVPMKIDCAND length");
+				return;
+			}
+			wpa_driver_tista_event_wireless_pmkidcand(
+				drv, custom, iwe->u.data.length);
+			break;
+		}
+
+		pos += iwe->len;
+	}
+}
+
+static int wpa_driver_tista_event_wireless_pmkidcand(
+	struct wpa_driver_ti_data *drv, const char *ev, size_t len)
+{
+	const struct iw_pmkid_cand *cand;
+	union wpa_event_data data;
+	const u8 *addr;
+
+	if (len < sizeof(*cand))
+		return -1;
+
+	cand = (const struct iw_pmkid_cand *) ev;
+	addr = (const u8 *) cand->bssid.sa_data;
+
+	wpa_printf(MSG_DEBUG, "PMKID candidate wireless event: "
+		   "flags=0x%x index=%d bssid=" MACSTR, cand->flags,
+		   cand->index, MAC2STR(addr));
+
+	os_memset(&data, 0, sizeof(data));
+	os_memcpy(data.pmkid_candidate.bssid, addr, ETH_ALEN);
+	data.pmkid_candidate.index = cand->index;
+	data.pmkid_candidate.preauth = cand->flags & IW_PMKID_CAND_PREAUTH;
+	wpa_supplicant_event(drv->ctx, EVENT_PMKID_CANDIDATE, &data);
+
+	return 0;
+}
+
+static int wpa_driver_tista_event_wireless_assocreqie(
+	struct wpa_driver_ti_data *drv, const char *ev, int len)
+{
+	if (len < 0)
+		return -1;
+
+	wpa_hexdump(MSG_DEBUG, "AssocReq IE wireless event", (const u8 *) ev,
+		    len);
+	os_free(drv->assoc_req_ies);
+	drv->assoc_req_ies = os_malloc(len);
+	if (drv->assoc_req_ies == NULL) {
+		drv->assoc_req_ies_len = 0;
+		return -1;
+	}
+	os_memcpy(drv->assoc_req_ies, ev, len);
+	drv->assoc_req_ies_len = len;
+
+	return 0;
+}
+
+static int wpa_driver_tista_event_wireless_assocrespie(
+	struct wpa_driver_ti_data *drv, const char *ev, int len)
+{
+	if (len < 0)
+		return -1;
+
+	wpa_hexdump(MSG_DEBUG, "AssocResp IE wireless event", (const u8 *) ev,
+		    len);
+	os_free(drv->assoc_resp_ies);
+	drv->assoc_resp_ies = os_malloc(len);
+	if (drv->assoc_resp_ies == NULL) {
+		drv->assoc_resp_ies_len = 0;
+		return -1;
+	}
+	os_memcpy(drv->assoc_resp_ies, ev, len);
+	drv->assoc_resp_ies_len = len;
+
+	return 0;
+}
+
+static void wpa_driver_tista_event_wireless_custom(void *ctx, void *priv, char *custom)
+{
+	union wpa_event_data data;
+
+	wpa_printf(MSG_MSGDUMP, "TISTA: Custom wireless event: '%s'",
+		   custom);
+
+	os_memset(&data, 0, sizeof(data));
+	/* Host AP driver */
+	if (os_strncmp(custom, "MLME-MICHAELMICFAILURE.indication", 33) == 0) {
+		data.michael_mic_failure.unicast =
+			os_strstr(custom, " unicast ") != NULL;
+		wpa_supplicant_event(ctx, EVENT_MICHAEL_MIC_FAILURE, &data);
+	} else if (os_strncmp(custom, "ASSOCINFO(ReqIEs=", 17) == 0) {
+		char *spos;
+		int bytes;
+
+		spos = custom + 17;
+
+
+		bytes = strspn(spos, "0123456789abcdefABCDEF");
+		if (!bytes || (bytes & 1))
+			return;
+		bytes /= 2;
+
+		data.assoc_info.req_ies = os_malloc(bytes);
+		if (data.assoc_info.req_ies == NULL)
+			return;
+
+		data.assoc_info.req_ies_len = bytes;
+		hexstr2bin(spos, data.assoc_info.req_ies, bytes);
+
+		spos += bytes * 2;
+
+		data.assoc_info.resp_ies = NULL;
+		data.assoc_info.resp_ies_len = 0;
+
+		if (os_strncmp(spos, " RespIEs=", 9) == 0) {
+			spos += 9;
+
+			bytes = strspn(spos, "0123456789abcdefABCDEF");
+			if (!bytes || (bytes & 1))
+				goto done;
+			bytes /= 2;
+
+			data.assoc_info.resp_ies = os_malloc(bytes);
+			if (data.assoc_info.resp_ies == NULL)
+				goto done;
+
+			data.assoc_info.resp_ies_len = bytes;
+			hexstr2bin(spos, data.assoc_info.resp_ies, bytes);
+		}
+
+		wpa_supplicant_event(ctx, EVENT_ASSOCINFO, &data);
+
+	done:
+		os_free(data.assoc_info.resp_ies);
+		os_free(data.assoc_info.req_ies);
+#ifdef CONFIG_PEERKEY
+	} else if (os_strncmp(custom, "STKSTART.request=", 17) == 0) {
+        if (hwaddr_aton(custom + 17, data.stkstart.peer)) {
+			wpa_printf(MSG_DEBUG, "TISTA: unrecognized "
+				   "STKSTART.request '%s'", custom + 17);
+			return;
+		}
+		wpa_supplicant_event(ctx, EVENT_STKSTART, &data);
+#endif /* CONFIG_PEERKEY */
+#ifdef ANDROID
+	} else if (os_strncmp(custom, "STOP", 4) == 0) {
+		wpa_msg(ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STOPPED");
+	} else if (os_strncmp(custom, "START", 5) == 0) {
+		wpa_msg(ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STARTED");
+#endif /* ANDROID */
+	}
+    else if( os_strncmp(custom, "SCAN_COMPLETE=", 14) == 0)
+    {
+        struct wpa_driver_ti_data *drv = priv;
+        int sClient;
+
+        os_memcpy(&sClient, &custom[14], 4);
+        wpa_printf(MSG_DEBUG, "TISTA: Custom wireless event - scan complete. "
+                              "Client_id = %d\n",sClient);
+
+        drv->scan_complete_events = 1;
+
+        eloop_cancel_timeout(wpa_driver_tista_scan_timeout,
+                     drv, ctx);
+        wpa_supplicant_event(ctx, EVENT_SCAN_RESULTS, NULL);
+        custom[14] = '\0';
+    }
+    wpa_printf(MSG_DEBUG, "TISTA: Custom wireless event: 7. custom = %s\n", custom);
+}
+
+static int wpa_driver_tista_event_wireless_michaelmicfailure(
+	void *ctx, const char *ev, size_t len)
+{
+	const struct iw_michaelmicfailure *mic;
+	union wpa_event_data data;
+
+	if (len < sizeof(*mic))
+		return -1;
+
+	mic = (const struct iw_michaelmicfailure *) ev;
+
+	wpa_printf(MSG_DEBUG, "Michael MIC failure wireless event: "
+		   "flags=0x%x src_addr=" MACSTR, mic->flags,
+		   MAC2STR(mic->src_addr.sa_data));
+
+	os_memset(&data, 0, sizeof(data));
+	data.michael_mic_failure.unicast = !(mic->flags & IW_MICFAILURE_GROUP);
+	wpa_supplicant_event(ctx, EVENT_MICHAEL_MIC_FAILURE, &data);
+
+	return 0;
+}
+
+static void wpa_driver_tista_event_assoc_ies(struct wpa_driver_ti_data *drv)
+{
+	union wpa_event_data data;
+
+	if (drv->assoc_req_ies == NULL && drv->assoc_resp_ies == NULL)
+		return;
+
+	os_memset(&data, 0, sizeof(data));
+	if (drv->assoc_req_ies) {
+		data.assoc_info.req_ies = drv->assoc_req_ies;
+		drv->assoc_req_ies = NULL;
+		data.assoc_info.req_ies_len = drv->assoc_req_ies_len;
+	}
+	if (drv->assoc_resp_ies) {
+		data.assoc_info.resp_ies = drv->assoc_resp_ies;
+		drv->assoc_resp_ies = NULL;
+		data.assoc_info.resp_ies_len = drv->assoc_resp_ies_len;
+	}
+
+	wpa_supplicant_event(drv->ctx, EVENT_ASSOCINFO, &data);
+
+	os_free(data.assoc_info.req_ies);
+	os_free(data.assoc_info.resp_ies);
+}
+
+
+/**
+ * wpa_driver_tista_set_ssid - Set SSID, SIOCSIWESSID
+ * @priv: Pointer to private driver data
+ * @ssid: SSID
+ * @ssid_len: Length of SSID (0..32)
+ * Returns: 0 on success, -1 on failure
+ */
+int wpa_driver_tista_set_ssid(void *priv, const u8 *ssid, size_t ssid_len)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	struct iwreq iwr;
+	int    ret = 0;
+	char   buf[33];
+
+    if (ssid_len > 32)
+    {
+        return -1;
+    }
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	/* flags: 1 = ESSID is active, 0 = not (promiscuous) */
+	iwr.u.essid.flags = (ssid_len != 0);
+	os_memset(buf, 0, sizeof(buf));
+	os_memcpy(buf, ssid, ssid_len);
+	iwr.u.essid.pointer = (caddr_t) buf;
+	if (drv->we_version_compiled < 21) {
+		/* For historic reasons, set SSID length to include one extra
+		 * character, C string nul termination, even though SSID is
+		 * really an octet string that should not be presented as a C
+		 * string. Some Linux drivers decrement the length by one and
+		 * can thus end up missing the last octet of the SSID if the
+		 * length is not incremented here. WE-21 changes this to
+		 * explicitly require the length _not_ to include nul
+		 * termination. */
+		if (ssid_len)
+			ssid_len++;
+	}
+	iwr.u.essid.length = ssid_len;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWESSID, &iwr) < 0) 
+    {
+		perror("ioctl[SIOCSIWESSID]");
+		ret = -1;
+	}
+	return ret;
+}
+
+/*
+Public Functions
+*/
+
+
+
+int wpa_driver_tista_parse_custom(void *ctx, const void *custom)
+{
+	IPC_EV_DATA * pData = NULL;
+
+	pData = (IPC_EV_DATA *)custom;
+	wpa_printf(MSG_DEBUG, "uEventType %d", pData->EvParams.uEventType);
+	switch (pData->EvParams.uEventType) 
+    {
+		case	IPC_EVENT_LINK_SPEED:
+			wpa_printf(MSG_DEBUG, "IPC_EVENT_LINK_SPEED");
+			if(pData->uBufferSize == sizeof(u32))
+			{
+				wpa_printf(MSG_DEBUG, "wpa_driver_tista_parse_custom - update link_speed");
+				/* Dm: pStaDrv->link_speed = *((u32 *)pData->uBuffer) / 2; */
+			}
+     		break;
+
+		default:
+			wpa_printf(MSG_DEBUG, "Unknown event");
+			break;
+	}
+
+	return 0;
+}
+
+
+/*-----------------------------------------------------------------------------
+Routine Name: wpa_driver_tista_get_mac_addr
+Routine Description: return WLAN MAC address
+Arguments: 
+   priv - pointer to private data structure
+Return Value: pointer to BSSID
+-----------------------------------------------------------------------------*/
+const u8 *wpa_driver_tista_get_mac_addr( void *priv )
+{
+	struct wpa_driver_ti_data *drv = (struct wpa_driver_ti_data *)priv;
+	u8 mac[ETH_ALEN] = {0};
+
+	TI_CHECK_DRIVER( drv->driver_is_loaded, NULL );
+	if(0 != wpa_driver_tista_private_send(priv, CTRL_DATA_MAC_ADDRESS, NULL, 0,
+		mac, ETH_ALEN))
+	{
+		wpa_printf(MSG_ERROR, "ERROR - Failed to get mac address!");
+		os_memset(drv->own_addr, 0, ETH_ALEN);
+	}
+	else
+	{
+		os_memcpy(drv->own_addr, mac, ETH_ALEN);
+		wpa_printf(MSG_DEBUG, "Macaddr = " MACSTR, MAC2STR(drv->own_addr));
+	}
+	wpa_printf(MSG_DEBUG, "wpa_driver_tista_get_mac_addr success");
+
+	return (const u8 *)&drv->own_addr;
+}
+
+/**
+ * wpa_driver_tista_init - Initialize WE driver interface
+ * @ctx: context to be used when calling wpa_supplicant functions,
+ * e.g., wpa_supplicant_event()
+ * @ifname: interface name, e.g., wlan0
+ * Returns: Pointer to private data, %NULL on failure
+ */
+void * wpa_driver_tista_init(void *ctx, const char *ifname)
+{
+	struct wpa_driver_ti_data *drv;
+    struct sockaddr_nl local;
+    int s;
+
+	drv = os_zalloc(sizeof(*drv));
+	if (drv == NULL)
+		return NULL;
+
+	drv->ctx = ctx;
+	os_strncpy(drv->ifname, ifname, sizeof(drv->ifname));
+	drv->ioctl_sock = socket(PF_INET, SOCK_DGRAM, 0);
+	if (drv->ioctl_sock < 0) 
+    {
+		perror("socket");
+		os_free(drv);
+		return NULL;
+	}
+
+    s = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+	if (s < 0) {
+		perror("socket(PF_NETLINK,SOCK_RAW,NETLINK_ROUTE)");
+		close(drv->ioctl_sock);
+		os_free(drv);
+		return NULL;
+	}
+
+	os_memset(&local, 0, sizeof(local));
+	local.nl_family = AF_NETLINK;
+	local.nl_groups = RTMGRP_LINK;
+	if (bind(s, (struct sockaddr *) &local, sizeof(local)) < 0) {
+		perror("bind(netlink)");
+		close(s);
+		close(drv->ioctl_sock);
+		os_free(drv);
+		return NULL;
+	}
+
+	eloop_register_read_sock(s, wpa_driver_tista_event_receive, drv, ctx);
+	drv->event_sock = s;
+
+	/* Signal that driver is not stopped */
+	drv->driver_is_loaded = TRUE;
+
+	/* Set default scan type */
+	drv->scan_type = SCAN_TYPE_NORMAL_ACTIVE;
+	drv->force_merge_flag = 0;
+	scan_init(drv);
+
+	/* Set default amount of channels */
+	drv->scan_channels = check_and_get_build_channels();
+
+	/* Link Speed will be set by the message from the driver */
+	drv->link_speed = 0;
+
+	/* BtCoex mode is read from tiwlan.ini file */
+	drv->btcoex_mode = 0; /* SG_DISABLE */
+
+#ifdef CONFIG_WPS
+	/* The latest probe_req_ie for WSC */
+	drv->probe_req_ie = NULL;
+#endif
+
+    drv->mlme_sock = -1;
+
+	/* Number of sequential errors */
+	drv->errors = 0;
+
+#ifdef ANDROID
+    drv->skip_disconnect = 0;
+#endif
+
+    wpa_driver_tista_finish_drv_init(drv);
+
+	return drv;
+}
+
+/**
+ * wpa_driver_tista_deinit - Deinitialize WE driver interface
+ * @priv: Pointer to private data from wpa_driver_tista_init()
+ *
+ * Shut down driver interface and processing of driver events. Free
+ * private data buffer if one was allocated in wpa_driver_tista_init().
+ */
+void wpa_driver_tista_deinit(void *priv)
+{
+	struct wpa_driver_ti_data *drv = priv;
+    int flags;
+
+    eloop_cancel_timeout(wpa_driver_tista_scan_timeout, drv, drv->ctx);
+
+    /*
+     * Clear possibly configured driver parameters in order to make it
+     * easier to use the driver after wpa_supplicant has been terminated.
+    */
+	wpa_driver_tista_disconnect(drv);
+
+    wpa_driver_tista_send_oper_ifla(priv, 0, IF_OPER_UP);
+
+	eloop_unregister_read_sock(drv->event_sock);
+	if (drv->mlme_sock >= 0)
+		eloop_unregister_read_sock(drv->mlme_sock);
+
+	if (wpa_driver_tista_get_ifflags(drv, &flags) == 0)
+		(void) wpa_driver_tista_set_ifflags(drv, flags & ~IFF_UP);
+
+    close(drv->event_sock);
+	close(drv->ioctl_sock);
+	scan_exit(drv);
+#ifdef CONFIG_WPS
+	wpabuf_free(drv->probe_req_ie);
+	drv->probe_req_ie = NULL;
+#endif
+
+    if (drv->mlme_sock >= 0)
+    {
+        close(drv->mlme_sock);
+    }
+	os_free(drv->assoc_req_ies);
+	os_free(drv->assoc_resp_ies);
+	os_free(drv);
+}
+
+/**
+ * wpa_driver_tista_get_scan_results - Fetch the latest scan
+ * results
+ * @priv: Pointer to private driver data
+ * Returns: Scan results on success, -1 on failure
+ */
+struct wpa_scan_results * wpa_driver_tista_get_scan_results_internal(void *priv)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	size_t ap_num = 0, len;
+	int first;
+	u8 *res_buf;
+	struct iw_event iwe_buf, *iwe = &iwe_buf;
+	char *pos, *end, *custom;
+	struct wpa_scan_results *res;
+	struct wpa_scan_data data;
+    u16 flags = 0;
+
+#ifdef ANDROID
+	/* To make sure correctly parse scan results which is impacted by wext
+	 * version, first check range->we_version, if it is default value (0),
+ 	 * update again here */
+ 	if (drv->we_version_compiled == 0)
+		wpa_driver_tista_get_range(drv);
+#endif
+	
+
+	res = os_zalloc(sizeof(*res));
+	if (res == NULL) {
+		return NULL;
+	}
+
+	do {
+
+    	res_buf = wpa_driver_tista_giwscan(drv, &len, &flags);
+    	if (res_buf == NULL)
+    		return NULL;
+    
+    	ap_num = 0;
+    	first = 1;
+    
+    	pos = (char *) res_buf;
+    	end = (char *) res_buf + len;
+    	os_memset(&data, 0, sizeof(data));
+    
+    	while (pos + IW_EV_LCP_LEN <= end) {
+    		/* Event data may be unaligned, so make a local, aligned copy
+    		 * before processing. */
+    		os_memcpy(&iwe_buf, pos, IW_EV_LCP_LEN);
+    		if (iwe->len <= IW_EV_LCP_LEN)
+    			break;
+    
+    		custom = pos + IW_EV_POINT_LEN;
+    		if (wpa_driver_tista_19_iw_point(drv, iwe->cmd)) {
+    			/* WE-19 removed the pointer from struct iw_point */
+    			char *dpos = (char *) &iwe_buf.u.data.length;
+    			int dlen = dpos - (char *) &iwe_buf;
+    			os_memcpy(dpos, pos + IW_EV_LCP_LEN,
+    				  sizeof(struct iw_event) - dlen);
+    		} else {
+    			os_memcpy(&iwe_buf, pos, sizeof(struct iw_event));
+    			custom += IW_EV_POINT_OFF;
+    		}
+    
+    		switch (iwe->cmd) {
+    		case SIOCGIWAP:
+    			if (!first)
+    				wpa_driver_tista_add_scan_entry(res, &data);
+    			first = 0;
+    			os_free(data.ie);
+    			os_memset(&data, 0, sizeof(data));
+    			os_memcpy(data.res.bssid,
+    				  iwe->u.ap_addr.sa_data, ETH_ALEN);
+    			break;
+    		case SIOCGIWMODE:
+    			wpa_driver_tista_get_scan_mode(iwe, &data);
+    			break;
+    		case SIOCGIWESSID:
+    			wpa_driver_tista_get_scan_ssid(iwe, &data, custom, end);
+    			break;
+    		case SIOCGIWFREQ:
+    			wpa_driver_tista_get_scan_freq(iwe, &data);
+    			break;
+    		case IWEVQUAL:
+    			wpa_driver_tista_get_scan_qual(iwe, &data);
+    			break;
+    		case SIOCGIWENCODE:
+    			wpa_driver_tista_get_scan_encode(iwe, &data);
+    			break;
+    		case SIOCGIWRATE:
+    			wpa_driver_tista_get_scan_rate(iwe, &data, pos, end);
+    			break;
+    		case IWEVGENIE:
+    			wpa_driver_tista_get_scan_iwevgenie(iwe, &data, custom, end);
+    			break;
+    		case IWEVCUSTOM:
+    			wpa_driver_tista_get_scan_custom(iwe, &data, custom, end);
+    			break;
+    		}
+    
+    		pos += iwe->len;
+	    }
+
+    } while (flags);
+
+	os_free(res_buf);
+	res_buf = NULL;
+	if (!first)
+		wpa_driver_tista_add_scan_entry(res, &data);
+	os_free(data.ie);
+
+	wpa_printf(MSG_DEBUG, "Received %lu bytes of scan results (%lu BSSes)",
+		   (unsigned long) len, (unsigned long) res->num);
+
+	return res;
+}
+
+/**
+ * wpa_driver_tista_set_freq - Set frequency/channel,
+ * SIOCSIWFREQ
+ * @priv: Pointer to driver data 
+ * @freq: Frequency in MHz
+ * Returns: 0 on success, -1 on failure
+ */
+int wpa_driver_tista_set_freq(void *priv, int freq)
+{
+	struct wpa_driver_ti_data *drv = priv;
+	struct iwreq iwr;
+	int ret = 0;
+
+	os_memset(&iwr, 0, sizeof(iwr));
+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
+	iwr.u.freq.m = freq * 100000;
+	iwr.u.freq.e = 1;
+
+	if (ioctl(drv->ioctl_sock, SIOCSIWFREQ, &iwr) < 0) {
+		perror("ioctl[SIOCSIWFREQ]");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+/**
+ * wpa_driver_tista_scan_timeout - Scan timeout to report scan
+ * completion
+ * @eloop_ctx: Unused
+ * @timeout_ctx: ctx argument
+ * This function can be used as registered timeout when starting a scan to
+ * generate a scan completed event if the driver does not report this.
+ */
+void wpa_driver_tista_scan_timeout(void *eloop_ctx, void *timeout_ctx)
+{
+    wpa_printf(MSG_DEBUG, "Scan timeout - try to get results");
+	wpa_supplicant_event(timeout_ctx, EVENT_SCAN_RESULTS, NULL);
+}
+/*----------------------------------------------------------------------------*/
+/*----------------------------------------------------------------------------*/
+
+const struct wpa_driver_ops wpa_driver_custom_ops = {
+	.name = TIWLAN_DRV_NAME,
+	.desc = "TI Station Driver (1271/3 and 1281/3)",
+	.get_bssid = wpa_driver_tista_get_bssid,
+	.get_ssid = wpa_driver_tista_get_ssid,
+	.set_wpa = wpa_driver_tista_set_wpa,
+	.set_key = wpa_driver_tista_set_key,
+	.set_countermeasures = wpa_driver_tista_set_countermeasures,
+	.set_drop_unencrypted = wpa_driver_tista_set_drop_unencrypted,
+	.scan = wpa_driver_tista_scan,
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+	.get_scan_results2 = wpa_driver_tista_get_scan_results,
+#else
+	.get_scan_results = wpa_driver_tista_get_scan_results,
+#endif
+	.deauthenticate = wpa_driver_tista_deauthenticate,
+	.disassociate = wpa_driver_tista_disassociate,
+	.associate = wpa_driver_tista_associate,
+	.set_auth_alg = wpa_driver_tista_set_auth_alg,
+	.get_mac_addr = wpa_driver_tista_get_mac_addr,
+	.init = wpa_driver_tista_init,
+	.deinit = wpa_driver_tista_deinit,
+	.add_pmkid = wpa_driver_tista_add_pmkid,
+	.remove_pmkid = wpa_driver_tista_remove_pmkid,
+	.flush_pmkid = wpa_driver_tista_flush_pmkid,
+	.set_operstate = wpa_driver_tista_set_operstate,
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+	.set_mode = wpa_driver_tista_set_mode,
+	.set_probe_req_ie = wpa_driver_tista_set_probe_req_ie,
+#endif
+	.driver_cmd = wpa_driver_tista_driver_cmd,
+	.set_ssid = wpa_driver_tista_set_ssid
+};
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/src/drivers/driver_ti.h wpa_supplicant_new/src/drivers/driver_ti.h
--- wpa_supplicant_original/src/drivers/driver_ti.h	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant_new/src/drivers/driver_ti.h	2011-03-23 16:18:37.187989000 +0200
@@ -0,0 +1,131 @@
+/*
+ * driver_ti.h
+ *
+ * Copyright 2001-2010 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef _DRIVER_TI_H_
+#define _DRIVER_TI_H_
+
+#include "wireless_copy.h"
+#include "common.h"
+#include "driver.h"
+#include "l2_packet.h"
+#include "eloop.h"
+#include "priv_netlink.h"
+#include "wpa_ctrl.h"
+#include "wpa_supplicant_i.h"
+#include "config.h"
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+#include "ieee802_11_defs.h"
+#else
+#include "wpa.h"
+#endif
+#include "cu_ostypes.h"
+#include "STADExternalIf.h"
+#include "convert.h"
+#include "shlist.h"
+
+
+#define TIWLAN_DRV_NAME         "tiwlan0"
+
+#define NUMBER_SCAN_CHANNELS_FCC        11
+#define NUMBER_SCAN_CHANNELS_ETSI       13
+#define NUMBER_SCAN_CHANNELS_MKK1       14
+
+#define RX_SELF_FILTER			0
+#define RX_BROADCAST_FILTER		1
+#define RX_IPV4_MULTICAST_FILTER	2
+#define RX_IPV6_MULTICAST_FILTER	3
+
+#define MAX_NUMBER_SEQUENTIAL_ERRORS	4
+#define WPA_DRIVER_TI_WAIT_US		400000
+
+typedef enum 
+{
+	BLUETOOTH_COEXISTENCE_MODE_ENABLED = 0,
+	BLUETOOTH_COEXISTENCE_MODE_DISABLED,
+	BLUETOOTH_COEXISTENCE_MODE_SENSE
+} EUIBTCoexMode;
+
+typedef struct
+{
+    U32 temp; /* the place of the IE's id and length */
+    U32 MissedBeacons;
+    U8 snr;       /* The current average SNR in db - For Data Packets*/
+    U8 snrBeacon;     /* The current average SNR in db - For Beacon Packets*/
+    S8 rssi;      /* The current average RSSI  - For Data Packets*/
+    S8 rssiBeacon;
+}TCuCommon_RoamingStatisticsTable;
+
+struct wpa_driver_ti_data 
+{
+	void         *ctx;
+	char         ifname[IFNAMSIZ + 1];
+    int          ifindex;
+    int          ifindex2;
+    int          if_removed;
+	int          ioctl_sock;
+    int          mlme_sock;
+    int          event_sock;
+	u8           own_addr[ETH_ALEN];        /* MAC address of WLAN interface */
+	int          driver_is_loaded;          /* TRUE/FALSE flag if driver is already loaded and can be accessed */
+	int          scan_type;                 /* SCAN_TYPE_NORMAL_ACTIVE or  SCAN_TYPE_NORMAL_PASSIVE */
+	int          force_merge_flag;		    /* Force scan results merge */
+	int          scan_channels;             /* Number of allowed scan channels */
+	unsigned int link_speed;                /* Link Speed */
+	u32          btcoex_mode;		        /* BtCoex Mode */
+	int          last_scan;			        /* Last scan type */
+	SHLIST       scan_merge_list;		    /* Previous scan list */
+#ifdef CONFIG_WPS
+	struct       wpabuf *probe_req_ie;      /* Store the latest probe_req_ie for WSC */
+#endif
+	int          errors;			        /* Number of sequential errors */
+    int          operstate;
+    struct       wpa_driver_capa capa;
+    int          has_capability;
+    int          we_version_compiled;
+    u8           *assoc_req_ies;
+	size_t       assoc_req_ies_len;
+	u8           *assoc_resp_ies;
+	size_t       assoc_resp_ies_len;
+    int          scan_complete_events;
+
+#ifdef ANDROID
+    int          skip_disconnect;
+#endif
+};
+
+/*
+ * Data structure for collecting scan results. This is needed to allow
+ * the various methods of reporting IEs to be combined into a single IE buffer.
+ */
+struct wpa_scan_data 
+{
+	struct wpa_scan_res res;
+	u8 *ie;
+	size_t ie_len;
+	u8 ssid[32];
+	size_t ssid_len;
+	int maxrate;
+};
+
+void     wpa_driver_tista_scan_timeout(void *eloop_ctx, void *timeout_ctx);
+void     wpa_driver_tista_deinit(void *priv);
+int      wpa_driver_tista_set_freq(void *priv, int freq);
+struct   wpa_scan_results * wpa_driver_tista_get_scan_results_internal(void *priv);
+const    u8 *wpa_driver_tista_get_mac_addr( void *priv );
+int      wpa_driver_tista_set_ssid(void *priv, const u8 *ssid, size_t ssid_len);
+
+#endif /* _DRIVER_TI_H_ */
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/src/drivers/driver_wext.c wpa_supplicant_new/src/drivers/driver_wext.c
--- wpa_supplicant_original/src/drivers/driver_wext.c	2011-03-23 16:18:10.036280000 +0200
+++ wpa_supplicant_new/src/drivers/driver_wext.c	2011-03-23 16:18:37.218989000 +0200
@@ -34,7 +34,7 @@
 #include "wpa_ctrl.h"
 #include "wpa_supplicant_i.h"
 #include "config_ssid.h"
-#include "config.h"
+
 
 static int wpa_driver_wext_flush_pmkid(void *priv);
 static int wpa_driver_wext_get_range(void *priv);
@@ -142,7 +142,7 @@
 	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
 
 	if (ioctl(drv->ioctl_sock, SIOCGIWAP, &iwr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCGIWAP]");
+		perror("ioctl[SIOCGIWAP]");
 		ret = -1;
 	}
 	os_memcpy(bssid, iwr.u.ap_addr.sa_data, ETH_ALEN);
@@ -172,7 +172,7 @@
 		os_memset(iwr.u.ap_addr.sa_data, 0, ETH_ALEN);
 
 	if (ioctl(drv->ioctl_sock, SIOCSIWAP, &iwr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWAP]");
+		perror("ioctl[SIOCSIWAP]");
 		ret = -1;
 	}
 
@@ -198,7 +198,7 @@
 	iwr.u.essid.length = 32;
 
 	if (ioctl(drv->ioctl_sock, SIOCGIWESSID, &iwr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCGIWESSID]");
+		perror("ioctl[SIOCGIWESSID]");
 		ret = -1;
 	} else {
 		ret = iwr.u.essid.length;
@@ -256,7 +256,7 @@
 	iwr.u.essid.length = ssid_len;
 
 	if (ioctl(drv->ioctl_sock, SIOCSIWESSID, &iwr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWESSID]");
+		perror("ioctl[SIOCSIWESSID]");
 		ret = -1;
 	}
 
@@ -282,7 +282,7 @@
 	iwr.u.freq.e = 1;
 
 	if (ioctl(drv->ioctl_sock, SIOCSIWFREQ, &iwr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWFREQ]");
+		perror("ioctl[SIOCSIWFREQ]");
 		ret = -1;
 	}
 
@@ -363,8 +363,6 @@
 		wpa_msg(ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STOPPED");
 	} else if (os_strncmp(custom, "START", 5) == 0) {
 		wpa_msg(ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STARTED");
-	} else if (os_strncmp(custom, "HANG", 4) == 0) {
-		wpa_msg(ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
 #endif /* ANDROID */
 	}
 }
@@ -544,7 +542,6 @@
 					wpa_supplicant_event(ctx, EVENT_DISASSOC,
 						     NULL);
 #ifdef ANDROID
-					wpa_driver_wext_disconnect(drv);
 				}
 #endif
 			
@@ -809,7 +806,7 @@
 			(struct sockaddr *) &from, &fromlen);
 	if (left < 0) {
 		if (errno != EINTR && errno != EAGAIN)
-			wpa_printf(MSG_ERROR, "%s: recvfrom(netlink): %d", __func__, errno);
+			perror("recvfrom(netlink)");
 		return;
 	}
 
@@ -868,7 +865,7 @@
 	os_memset(&ifr, 0, sizeof(ifr));
 	os_strlcpy(ifr.ifr_name, ifname, IFNAMSIZ);
 	if (ioctl(drv->ioctl_sock, SIOCGIFFLAGS, (caddr_t) &ifr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCGIFFLAGS]");
+		perror("ioctl[SIOCGIFFLAGS]");
 		return -1;
 	}
 	*flags = ifr.ifr_flags & 0xffff;
@@ -897,7 +894,7 @@
 	os_strlcpy(ifr.ifr_name, ifname, IFNAMSIZ);
 	ifr.ifr_flags = flags & 0xffff;
 	if (ioctl(drv->ioctl_sock, SIOCSIFFLAGS, (caddr_t) &ifr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIFFLAGS]");
+		perror("SIOCSIFFLAGS");
 		return -1;
 	}
 	return 0;
@@ -937,14 +934,14 @@
 
 	drv->ioctl_sock = socket(PF_INET, SOCK_DGRAM, 0);
 	if (drv->ioctl_sock < 0) {
-		wpa_printf(MSG_ERROR, "%s: socket(PF_INET,SOCK_DGRAM)", __func__);
+		perror("socket(PF_INET,SOCK_DGRAM)");
 		os_free(drv);
 		return NULL;
 	}
 
 	s = socket(PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
 	if (s < 0) {
-		wpa_printf(MSG_ERROR, "%s: socket(PF_NETLINK,SOCK_RAW,NETLINK_ROUTE)", __func__);
+		perror("socket(PF_NETLINK,SOCK_RAW,NETLINK_ROUTE)");
 		close(drv->ioctl_sock);
 		os_free(drv);
 		return NULL;
@@ -954,7 +951,7 @@
 	local.nl_family = AF_NETLINK;
 	local.nl_groups = RTMGRP_LINK;
 	if (bind(s, (struct sockaddr *) &local, sizeof(local)) < 0) {
-		wpa_printf(MSG_ERROR, "bind(netlink)");
+		perror("bind(netlink)");
 		close(s);
 		close(drv->ioctl_sock);
 		os_free(drv);
@@ -967,7 +964,7 @@
 	drv->mlme_sock = -1;
 #ifdef ANDROID
 	drv->errors = 0;
-	drv->driver_is_started = TRUE;
+	drv->driver_is_loaded = TRUE;
 	drv->skip_disconnect = 0;
 #endif
 	wpa_driver_wext_finish_drv_init(drv);
@@ -1077,6 +1074,7 @@
 	os_free(drv);
 }
 
+
 /**
  * wpa_driver_wext_scan_timeout - Scan timeout to report scan completion
  * @eloop_ctx: Unused
@@ -1091,34 +1089,6 @@
 	wpa_supplicant_event(timeout_ctx, EVENT_SCAN_RESULTS, NULL);
 }
 
-/**
- * wpa_driver_wext_set_scan_timeout - Set scan timeout to report scan completion
- * @priv:  Pointer to private wext data from wpa_driver_wext_init()
- *
- * This function can be used to set registered timeout when starting a scan to
- * generate a scan completed event if the driver does not report this.
- */
-static void wpa_driver_wext_set_scan_timeout(void *priv)
-{
-	struct wpa_driver_wext_data *drv = priv;
-	int timeout = 10; /* In case scan A and B bands it can be long */
-
-	/* Not all drivers generate "scan completed" wireless event, so try to
-	 * read results after a timeout. */
-	if (drv->scan_complete_events) {
-		/*
-		 * The driver seems to deliver SIOCGIWSCAN events to notify
-		 * when scan is complete, so use longer timeout to avoid race
-		 * conditions with scanning and following association request.
-		 */
-		timeout = 30;
-	}
-	wpa_printf(MSG_DEBUG, "Scan requested - scan timeout %d seconds",
-		   timeout);
-	eloop_cancel_timeout(wpa_driver_wext_scan_timeout, drv, drv->ctx);
-	eloop_register_timeout(timeout, 0, wpa_driver_wext_scan_timeout, drv,
-			       drv->ctx);
-}
 
 /**
  * wpa_driver_wext_scan - Request the driver to initiate scan
@@ -1133,7 +1103,7 @@
 {
 	struct wpa_driver_wext_data *drv = priv;
 	struct iwreq iwr;
-	int ret = 0;
+	int ret = 0, timeout;
 	struct iw_scan_req req;
 #ifdef ANDROID
 	struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)(drv->ctx);
@@ -1170,93 +1140,26 @@
 	}
 
 	if (ioctl(drv->ioctl_sock, SIOCSIWSCAN, &iwr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWSCAN]");
+		perror("ioctl[SIOCSIWSCAN]");
 		ret = -1;
 	}
 
-	wpa_driver_wext_set_scan_timeout(priv);
-
-	return ret;
-}
-
-/**
- * wpa_driver_wext_combo_scan - Request the driver to initiate combo scan
- * @priv: Pointer to private wext data from wpa_driver_wext_init()
- * @ssid_ptr: Pointer to current SSID from configuration list or %NULL to
- *	scan for all SSIDs (either active scan with broadcast SSID or passive
- *	scan)
- * @ssid_conf: SSID list from the configuration
- * Returns: 0 on success, -1 on failure
- *	Also updates @ssid_ptr to next specific scan item
- */
-int wpa_driver_wext_combo_scan(void *priv, struct wpa_ssid **ssid_ptr,
-			       struct wpa_ssid *ssid_conf)
-{
-	char buf[WEXT_CSCAN_BUF_LEN];
-	struct wpa_driver_wext_data *drv = priv;
-	struct iwreq iwr;
-	int ret = 0, timeout, i = 0, bp;
-	struct wpa_ssid *ssid, *ssid_orig;
-	u8 *ssid_nm = NULL;
-	size_t ssid_len = 0;
-
-	struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)(drv->ctx);
-	int scan_probe_flag = 0;
-
-	if (!drv->driver_is_started) {
-		wpa_printf(MSG_DEBUG, "%s: Driver stopped", __func__);
-		return 0;
-	}
-
-	wpa_printf(MSG_DEBUG, "%s: Start", __func__);
-
-	/* Set list of SSIDs */
-	ssid_orig = (*ssid_ptr);
-	ssid = (*ssid_ptr) ? (*ssid_ptr) : ssid_conf;
-	bp = WEXT_CSCAN_HEADER_SIZE;
-	os_memcpy(buf, WEXT_CSCAN_HEADER, bp);
-	while (i < WEXT_CSCAN_AMOUNT) {
-		if ((bp + IW_ESSID_MAX_SIZE + 10) >= (int)sizeof(buf))
-			break;
-		*ssid_ptr = ssid;
-		if (ssid == NULL)
-			break;
-		if (!ssid->disabled && ssid->scan_ssid) {
-			wpa_printf(MSG_DEBUG, "For Scan: %s", ssid->ssid);
-			buf[bp++] = WEXT_CSCAN_SSID_SECTION;
-			buf[bp++] = ssid->ssid_len;
-			os_memcpy(&buf[bp], ssid->ssid, ssid->ssid_len);
-			bp += ssid->ssid_len;
-			i++;
-		}
-		ssid = ssid->next;
-	}
-
-	/* Set list of channels */
-	buf[bp++] = WEXT_CSCAN_CHANNEL_SECTION;
-	buf[bp++] = 0;
-
-	/* Set passive dwell time (default is 250) */
-	buf[bp++] = WEXT_CSCAN_PASV_DWELL_SECTION;
-	buf[bp++] = (u8)WEXT_CSCAN_PASV_DWELL_TIME;
-	buf[bp++] = (u8)(WEXT_CSCAN_PASV_DWELL_TIME >> 8);
-
-	/* Set home dwell time (default is 40) */
-	buf[bp++] = WEXT_CSCAN_HOME_DWELL_SECTION;
-	buf[bp++] = (u8)WEXT_CSCAN_HOME_DWELL_TIME;
-	buf[bp++] = (u8)(WEXT_CSCAN_HOME_DWELL_TIME >> 8);
-
-	os_memset(&iwr, 0, sizeof(iwr));
-	os_strncpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
-	iwr.u.data.pointer = buf;
-	iwr.u.data.length = bp;
-
-	if ((ret = ioctl(drv->ioctl_sock, SIOCSIWPRIV, &iwr)) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWPRIV] (cscan): %d", ret);
-		*ssid_ptr = ssid_orig;
+	/* Not all drivers generate "scan completed" wireless event, so try to
+	 * read results after a timeout. */
+	timeout = 5;
+	if (drv->scan_complete_events) {
+		/*
+		 * The driver seems to deliver SIOCGIWSCAN events to notify
+		 * when scan is complete, so use longer timeout to avoid race
+		 * conditions with scanning and following association request.
+		 */
+		timeout = 30;
 	}
-
-	wpa_driver_wext_set_scan_timeout(priv);
+	wpa_printf(MSG_DEBUG, "Scan requested (ret=%d) - scan timeout %d "
+		   "seconds", ret, timeout);
+	eloop_cancel_timeout(wpa_driver_wext_scan_timeout, drv, drv->ctx);
+	eloop_register_timeout(timeout, 0, wpa_driver_wext_scan_timeout, drv,
+			       drv->ctx);
 
 	return ret;
 }
@@ -1292,7 +1195,7 @@
 				   "trying larger buffer (%lu bytes)",
 				   (unsigned long) res_buf_len);
 		} else {
-			wpa_printf(MSG_ERROR, "ioctl[SIOCGIWSCAN]: %d", errno);
+			perror("ioctl[SIOCGIWSCAN]");
 			os_free(res_buf);
 			return NULL;
 		}
@@ -1730,7 +1633,7 @@
 		sizeof(range->enc_capa);
 
 	if (ioctl(drv->ioctl_sock, SIOCGIWRANGE, &iwr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCGIRANGE]");
+		perror("ioctl[SIOCGIWRANGE]");
 		os_free(range);
 		return -1;
 	} else if (iwr.u.data.length >= minlen &&
@@ -1815,7 +1718,7 @@
 
 	ret = ioctl(drv->ioctl_sock, SIOCSIWENCODEEXT, &iwr);
 	if (ret < 0)
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWENCODEEXT] PMK");
+		perror("ioctl[SIOCSIWENCODEEXT] PMK");
 	os_free(ext);
 
 	return ret;
@@ -1908,7 +1811,7 @@
 			ret = -2;
 		}
 
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWENCODEEXT]");
+		perror("ioctl[SIOCSIWENCODEEXT]");
 	}
 
 	os_free(ext);
@@ -1982,7 +1885,7 @@
 	iwr.u.encoding.length = key_len;
 
 	if (ioctl(drv->ioctl_sock, SIOCSIWENCODE, &iwr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWENCODE]");
+		perror("ioctl[SIOCSIWENCODE]");
 		ret = -1;
 	}
 
@@ -1994,7 +1897,7 @@
 		iwr.u.encoding.pointer = (caddr_t) NULL;
 		iwr.u.encoding.length = 0;
 		if (ioctl(drv->ioctl_sock, SIOCSIWENCODE, &iwr) < 0) {
-			wpa_printf(MSG_ERROR, "ioctl[SIOCSIWENCODE] (set_tx)");
+			perror("ioctl[SIOCSIWENCODE] (set_tx)");
 			ret = -1;
 		}
 	}
@@ -2043,7 +1946,7 @@
 	iwr.u.data.length = sizeof(mlme);
 
 	if (ioctl(drv->ioctl_sock, SIOCSIWMLME, &iwr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWMLME]");
+		perror("ioctl[SIOCSIWMLME]");
 		ret = -1;
 	}
 
@@ -2068,7 +1971,7 @@
 	os_memset(&iwr, 0, sizeof(iwr));
 	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
 	if (ioctl(drv->ioctl_sock, SIOCGIWMODE, &iwr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCGIWMODE]");
+		perror("ioctl[SIOCGIWMODE]");
 		iwr.u.mode = IW_MODE_INFRA;
 	}
 
@@ -2126,7 +2029,7 @@
 	iwr.u.data.length = ie_len;
 
 	if (ioctl(drv->ioctl_sock, SIOCSIWGENIE, &iwr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWGENIE]");
+		perror("ioctl[SIOCSIWGENIE]");
 		ret = -1;
 	}
 
@@ -2203,7 +2106,7 @@
 	}
 
 	if (ioctl(drv->ioctl_sock, SIOCSIWENCODE, &iwr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWENCODE]");
+		perror("ioctl[SIOCSIWENCODE]");
 		ret = -1;
 	}
 
@@ -2352,8 +2255,6 @@
 int wpa_driver_wext_set_mode(void *priv, int mode)
 {
 	struct wpa_driver_wext_data *drv = priv;
-	struct wpa_supplicant *wpa_s = (struct wpa_supplicant *)(drv->ctx);
-	struct wpa_config *wpa_conf = (struct wpa_config *)(wpa_s->conf);
 	struct iwreq iwr;
 	int ret = -1, flags;
 	unsigned int new_mode = mode ? IW_MODE_ADHOC : IW_MODE_INFRA;
@@ -2361,21 +2262,13 @@
 	os_memset(&iwr, 0, sizeof(iwr));
 	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
 	iwr.u.mode = new_mode;
-
-	if (new_mode == IW_MODE_INFRA)
-		wpa_conf->ap_scan = 1;
-	else if (new_mode == IW_MODE_ADHOC)
-		wpa_conf->ap_scan = 2;
-	else
-		wpa_printf(MSG_ERROR,"wpa_driver_tista_set_network_mode: Unspecified mode");
-
 	if (ioctl(drv->ioctl_sock, SIOCSIWMODE, &iwr) == 0) {
 		ret = 0;
 		goto done;
 	}
 
 	if (errno != EBUSY) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCSIWMODE]");
+		perror("ioctl[SIOCSIWMODE]");
 		goto done;
 	}
 
@@ -2384,7 +2277,7 @@
 	 * down, try to set the mode again, and bring it back up.
 	 */
 	if (ioctl(drv->ioctl_sock, SIOCGIWMODE, &iwr) < 0) {
-		wpa_printf(MSG_ERROR, "ioctl[SIOCGIWMODE]");
+		perror("ioctl[SIOCGIWMODE]");
 		goto done;
 	}
 
@@ -2399,7 +2292,7 @@
 		/* Try to set the mode again while the interface is down */
 		iwr.u.mode = new_mode;
 		if (ioctl(drv->ioctl_sock, SIOCSIWMODE, &iwr) < 0)
-			wpa_printf(MSG_ERROR, "ioctl[SIOCSIWMODE]");
+			perror("ioctl[SIOCSIWMODE]");
 		else
 			ret = 0;
 
@@ -2436,7 +2329,7 @@
 
 	if (ioctl(drv->ioctl_sock, SIOCSIWPMKSA, &iwr) < 0) {
 		if (errno != EOPNOTSUPP)
-			wpa_printf(MSG_ERROR, "ioctl[SIOCSIWPMKSA]");
+			perror("ioctl[SIOCSIWPMKSA]");
 		ret = -1;
 	}
 
@@ -2535,26 +2428,29 @@
 
 	wpa_printf(MSG_DEBUG, "%s %s len = %d", __func__, cmd, buf_len);
 
-	if (!drv->driver_is_started && (os_strcasecmp(cmd, "START") != 0)) {
+	if (!drv->driver_is_loaded && (os_strcasecmp(cmd, "START") != 0)) {
 		wpa_printf(MSG_ERROR,"WEXT: Driver not initialized yet");
 		return -1;
 	}
 
 	if (os_strcasecmp(cmd, "RSSI-APPROX") == 0) {
 		os_strncpy(cmd, "RSSI", MAX_DRV_CMD_SIZE);
-	} else if( os_strncasecmp(cmd, "SCAN-CHANNELS", 13) == 0 ) {
+	}
+	else if( os_strncasecmp(cmd, "SCAN-CHANNELS", 13) == 0 ) {
 		int no_of_chan;
 
 		no_of_chan = atoi(cmd + 13);
 		os_snprintf(cmd, MAX_DRV_CMD_SIZE, "COUNTRY %s",
 			wpa_driver_get_country_code(no_of_chan));
-	} else if (os_strcasecmp(cmd, "STOP") == 0) {
+	}
+	else if (os_strcasecmp(cmd, "STOP") == 0) {
 		if ((wpa_driver_wext_get_ifflags(drv, &flags) == 0) &&
 		    (flags & IFF_UP)) {
 			wpa_printf(MSG_ERROR, "WEXT: %s when iface is UP", cmd);
 			wpa_driver_wext_set_ifflags(drv, flags & ~IFF_UP);
 		}
-	} else if( os_strcasecmp(cmd, "RELOAD") == 0 ) {
+	}
+	else if( os_strcasecmp(cmd, "RELOAD") == 0 ) {
 		wpa_printf(MSG_DEBUG,"Reload command");
 		wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
 		return ret;
@@ -2566,7 +2462,9 @@
 	iwr.u.data.pointer = buf;
 	iwr.u.data.length = buf_len;
 
-	ret = ioctl(drv->ioctl_sock, SIOCSIWPRIV, &iwr);
+	if ((ret = ioctl(drv->ioctl_sock, SIOCSIWPRIV, &iwr)) < 0) {
+		perror("ioctl[SIOCSIWPRIV]");
+	}
 
 	if (ret < 0) {
 		wpa_printf(MSG_ERROR, "%s failed (%d): %s", __func__, ret, cmd);
@@ -2575,21 +2473,22 @@
 			drv->errors = 0;
 			wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
 		}
-	} else {
+	}
+	else {
 		drv->errors = 0;
 		ret = 0;
 		if ((os_strcasecmp(cmd, "RSSI") == 0) ||
 		    (os_strcasecmp(cmd, "LINKSPEED") == 0) ||
-		    (os_strcasecmp(cmd, "MACADDR") == 0) ||
-		    (os_strcasecmp(cmd, "GETPOWER") == 0) ||
-		    (os_strcasecmp(cmd, "GETBAND") == 0)) {
+		    (os_strcasecmp(cmd, "MACADDR") == 0)) {
 			ret = strlen(buf);
-		} else if (os_strcasecmp(cmd, "START") == 0) {
-			drv->driver_is_started = TRUE;
+		}
+		else if (os_strcasecmp(cmd, "START") == 0) {
+			drv->driver_is_loaded = TRUE;
 			/* os_sleep(0, WPA_DRIVER_WEXT_WAIT_US);
 			wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STARTED"); */
-		} else if (os_strcasecmp(cmd, "STOP") == 0) {
-			drv->driver_is_started = FALSE;
+		}
+		else if (os_strcasecmp(cmd, "STOP") == 0) {
+			drv->driver_is_loaded = FALSE;
 			/* wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STOPPED"); */
 		}
 		wpa_printf(MSG_DEBUG, "%s %s len = %d, %d", __func__, buf, ret, strlen(buf));
@@ -2609,7 +2508,6 @@
 	.set_countermeasures = wpa_driver_wext_set_countermeasures,
 	.set_drop_unencrypted = wpa_driver_wext_set_drop_unencrypted,
 	.scan = wpa_driver_wext_scan,
-	.combo_scan = wpa_driver_wext_combo_scan,
 	.get_scan_results2 = wpa_driver_wext_get_scan_results,
 	.deauthenticate = wpa_driver_wext_deauthenticate,
 	.disassociate = wpa_driver_wext_disassociate,
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/src/drivers/driver_wext.h wpa_supplicant_new/src/drivers/driver_wext.h
--- wpa_supplicant_original/src/drivers/driver_wext.h	2011-03-23 16:18:09.953312000 +0200
+++ wpa_supplicant_new/src/drivers/driver_wext.h	2011-03-23 16:18:37.236982000 +0200
@@ -45,7 +45,7 @@
 	int scan_complete_events;
 #ifdef ANDROID
 	int errors;
-	int driver_is_started;
+	int driver_is_loaded;
 	int skip_disconnect;
 #endif
 };
@@ -63,8 +63,6 @@
 			    int set_tx, const u8 *seq, size_t seq_len,
 			    const u8 *key, size_t key_len);
 int wpa_driver_wext_scan(void *priv, const u8 *ssid, size_t ssid_len);
-int wpa_driver_wext_combo_scan(void *priv, struct wpa_ssid **ssid_ptr,
-			       struct wpa_ssid *ssid_conf);
 struct wpa_scan_results * wpa_driver_wext_get_scan_results(void *priv);
 
 void wpa_driver_wext_scan_timeout(void *eloop_ctx, void *timeout_ctx);
@@ -94,23 +92,6 @@
 #define WPA_DRIVER_WEXT_WAIT_US		400000
 #define MAX_DRV_CMD_SIZE		248
 #define WEXT_NUMBER_SEQUENTIAL_ERRORS	4
-#define WEXT_CSCAN_AMOUNT		9
-#define WEXT_CSCAN_BUF_LEN		360
-#define WEXT_CSCAN_HEADER		"CSCAN S\x01\x00\x00S\x00"
-#define WEXT_CSCAN_HEADER_SIZE		12
-#define WEXT_CSCAN_SSID_SECTION		'S'
-#define WEXT_CSCAN_CHANNEL_SECTION	'C'
-#define WEXT_CSCAN_NPROBE_SECTION	'N'
-#define WEXT_CSCAN_ACTV_DWELL_SECTION	'A'
-#define WEXT_CSCAN_PASV_DWELL_SECTION	'P'
-#define WEXT_CSCAN_HOME_DWELL_SECTION	'H'
-#define WEXT_CSCAN_TYPE_SECTION		'T'
-#define WEXT_CSCAN_TYPE_DEFAULT		0
-#define WEXT_CSCAN_TYPE_PASSIVE		1
-#define WEXT_CSCAN_PASV_DWELL_TIME	130
-#define WEXT_CSCAN_PASV_DWELL_TIME_DEF	250
-#define WEXT_CSCAN_PASV_DWELL_TIME_MAX	3000
-#define WEXT_CSCAN_HOME_DWELL_TIME	130
 #endif
 
 #endif /* DRIVER_WEXT_H */
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/src/rsn_supp/wpa.c wpa_supplicant_new/src/rsn_supp/wpa.c
--- wpa_supplicant_original/src/rsn_supp/wpa.c	2011-03-23 16:18:10.802229000 +0200
+++ wpa_supplicant_new/src/rsn_supp/wpa.c	2011-03-23 16:18:39.930851000 +0200
@@ -285,7 +285,6 @@
 			wpa_sm_ether_send(sm, sm->bssid, ETH_P_EAPOL,
 					  buf, buflen);
 			os_free(buf);
-			return -2;
 		}
 
 		return -1;
@@ -381,7 +380,6 @@
 	struct wpa_eapol_ie_parse ie;
 	struct wpa_ptk *ptk;
 	u8 buf[8];
-	int res;
 
 	if (wpa_sm_get_network_ctx(sm) == NULL) {
 		wpa_printf(MSG_WARNING, "WPA: No SSID info found (msg 1 of "
@@ -409,13 +407,7 @@
 	}
 #endif /* CONFIG_NO_WPA2 */
 
-	res = wpa_supplicant_get_pmk(sm, src_addr, ie.pmkid);
-	if (res == -2) {
-		wpa_printf(MSG_DEBUG, "RSN: Do not reply to msg 1/4 - "
-			   "requesting full EAP authentication");
-		return;
-	}
-	if (res)
+	if (wpa_supplicant_get_pmk(sm, src_addr, ie.pmkid))
 		goto failed;
 
 	if (sm->renew_snonce) {
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/src/utils/scanmerge.c wpa_supplicant_new/src/utils/scanmerge.c
--- wpa_supplicant_original/src/utils/scanmerge.c	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant_new/src/utils/scanmerge.c	2011-03-23 16:18:41.044763000 +0200
@@ -0,0 +1,343 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*-------------------------------------------------------------------*/
+#include "includes.h"
+#include "scanmerge.h"
+#include "shlist.h"
+
+#define IS_HIDDEN_AP(a)	(((a)->ssid_len == 0) || ((a)->ssid[0] == '\0'))
+
+scan_ssid_t *scan_get_ssid( scan_result_t *res_ptr )
+{
+    static scan_ssid_t ssid_temp;
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+    const u8 *res_ie;
+
+    res_ie = wpa_scan_get_ie(res_ptr, WLAN_EID_SSID);
+    if (!res_ie)
+        return NULL;
+    ssid_temp.ssid_len = (size_t)res_ie[1];
+    os_memcpy(ssid_temp.ssid, (res_ie + 2), ssid_temp.ssid_len);
+#else
+    ssid_temp.ssid_len = res_ptr->ssid_len;
+    os_memcpy(ssid_temp.ssid, res_ptr->ssid, ssid_temp.ssid_len);
+#endif
+    return &ssid_temp;
+}
+
+/*-----------------------------------------------------------------------------
+Routine Name: scan_init
+Routine Description: Inits scan merge list
+Arguments:
+   mydrv   - pointer to private driver data structure
+Return Value:
+-----------------------------------------------------------------------------*/
+void scan_init( struct wpa_driver_ti_data *mydrv )
+{
+    mydrv->last_scan = -1;
+    shListInitList(&(mydrv->scan_merge_list));
+}
+
+/*-----------------------------------------------------------------------------
+Routine Name: scan_free
+Routine Description: Frees scan structure private data
+Arguments:
+   ptr - pointer to private data structure
+Return Value:
+-----------------------------------------------------------------------------*/
+static void scan_free( void *ptr )
+{
+    os_free(ptr);
+}
+
+/*-----------------------------------------------------------------------------
+Routine Name: scan_exit
+Routine Description: Cleans scan merge list
+Arguments:
+   mydrv   - pointer to private driver data structure
+Return Value:
+-----------------------------------------------------------------------------*/
+void scan_exit( struct wpa_driver_ti_data *mydrv )
+{
+    shListDelAllItems(&(mydrv->scan_merge_list), scan_free);
+}
+
+/*-----------------------------------------------------------------------------
+Routine Name: scan_count
+Routine Description: Gives number of list elements
+Arguments:
+   mydrv   - pointer to private driver data structure
+Return Value: Number of elements in the list
+-----------------------------------------------------------------------------*/
+unsigned long scan_count( struct wpa_driver_ti_data *mydrv )
+{
+    return shListGetCount(&(mydrv->scan_merge_list));
+}
+
+/*-----------------------------------------------------------------------------
+Routine Name: scan_equal
+Routine Description: Compares bssid of scan result and scan merge structure
+Arguments:
+   val   - pointer to scan result structure
+   idata - pointer to scan merge structure
+Return Value: 1 - if equal, 0 - if not
+-----------------------------------------------------------------------------*/
+static int scan_equal( void *val,  void *idata )
+{
+    scan_ssid_t n_ssid, l_ssid, *p_ssid;
+    scan_result_t *new_res = (scan_result_t *)val;
+    scan_result_t *lst_res =
+               (scan_result_t *)(&(((scan_merge_t *)idata)->scanres));
+    int ret;
+    size_t len;
+
+    p_ssid = scan_get_ssid(new_res);
+    if (!p_ssid)
+        return 0;
+    os_memcpy(&n_ssid, p_ssid, sizeof(scan_ssid_t));
+    p_ssid = scan_get_ssid(lst_res);
+    if (!p_ssid)
+        return 0;
+    os_memcpy(&l_ssid, p_ssid, sizeof(scan_ssid_t));
+
+    len = (IS_HIDDEN_AP(&n_ssid) || IS_HIDDEN_AP(&l_ssid)) ?
+          0 : n_ssid.ssid_len;
+    ret = ((l_ssid.ssid_len != n_ssid.ssid_len) && (len != 0)) ||
+          (os_memcmp(new_res->bssid, lst_res->bssid, ETH_ALEN) ||
+           os_memcmp(n_ssid.ssid, l_ssid.ssid, len));
+    return !ret;
+}
+
+/*-----------------------------------------------------------------------------
+Routine Name: copy_scan_res
+Routine Description: copies scan result structure to scan merge list item
+Arguments:
+   dst - pointer to scan result structure in the list
+   src - source pointer to scan result structure
+Return Value: NONE
+-----------------------------------------------------------------------------*/
+void copy_scan_res( scan_result_t *dst, scan_result_t *src )
+{
+#ifdef WPA_SUPPLICANT_VER_0_5_X
+    if( IS_HIDDEN_AP(src) ) {
+        os_memcpy(src->ssid, dst->ssid, dst->ssid_len);
+        src->ssid_len = dst->ssid_len;
+    }
+#endif
+    os_memcpy(dst, src, sizeof(scan_result_t));
+}
+
+/*-----------------------------------------------------------------------------
+Routine Name: scan_add
+Routine Description: adds scan result structure to scan merge list
+Arguments:
+   head    - pointer to scan merge list head
+   res_ptr - pointer to scan result structure
+Return Value: Pointer to scan merge item
+-----------------------------------------------------------------------------*/
+static scan_merge_t *scan_add( SHLIST *head, scan_result_t *res_ptr )
+{
+    scan_merge_t *scan_ptr;
+    unsigned size = 0;
+
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+    size += res_ptr->ie_len;
+#endif
+    scan_ptr = (scan_merge_t *)os_malloc(sizeof(scan_merge_t) + size);
+    if( !scan_ptr )
+        return( NULL );
+    os_memcpy(&(scan_ptr->scanres), res_ptr, sizeof(scan_result_t) + size);
+    scan_ptr->count = SCAN_MERGE_COUNT;
+    shListInsLastItem(head, (void *)scan_ptr);
+    return scan_ptr;
+}
+
+/*-----------------------------------------------------------------------------
+Routine Name: scan_find
+Routine Description: Looks for scan merge item in scan results array
+Arguments:
+   scan_ptr - pointer to scan merge item
+   results - pointer to scan results array
+   number_items - current number of items
+Return Value: 1 - if item was found, 0 - otherwise
+-----------------------------------------------------------------------------*/
+static int scan_find( scan_merge_t *scan_ptr, scan_result_t *results,
+                      unsigned int number_items )
+{
+    unsigned int i;
+
+    for(i=0;( i < number_items );i++) {
+        if( scan_equal(&(results[i]), scan_ptr) )
+            return 1;
+    }
+    return 0;
+}
+
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+/*-----------------------------------------------------------------------------
+Routine Name: scan_dup
+Routine Description: Create copy of scan results entry
+Arguments:
+   res_ptr - pointer to scan result item
+Return Value: pointer to new scan result item, or NULL
+-----------------------------------------------------------------------------*/
+static scan_result_t *scan_dup( scan_result_t *res_ptr )
+{
+    unsigned size;
+    scan_result_t *new_ptr;
+
+    if (!res_ptr)
+        return NULL;
+
+    size = sizeof(scan_result_t) + res_ptr->ie_len;
+    new_ptr = os_malloc(size);
+    if (!new_ptr)
+        return NULL;
+    if (res_ptr) {
+        os_memcpy(new_ptr, res_ptr, size);
+    }
+    return new_ptr;
+}
+#endif
+
+/*-----------------------------------------------------------------------------
+Routine Name: scan_merge
+Routine Description: Merges current scan results with previous
+Arguments:
+   mydrv   - pointer to private driver data structure
+   results - pointer to scan results array
+   number_items - current number of items
+   max_size - maximum namber of items
+Return Value: Merged number of items
+-----------------------------------------------------------------------------*/
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+unsigned int scan_merge( struct wpa_driver_ti_data *mydrv,
+                         scan_result_t **results, int force_flag,
+                         unsigned int number_items, unsigned int max_size )
+#else
+unsigned int scan_merge( struct wpa_driver_ti_data *mydrv,
+                         scan_result_t *results, int force_flag,
+                         unsigned int number_items, unsigned int max_size )
+#endif
+{
+    SHLIST *head = &(mydrv->scan_merge_list);
+    SHLIST *item, *del_item;
+    scan_result_t *res_ptr;
+    scan_merge_t *scan_ptr;
+    unsigned int i;
+
+    /* Prepare items for removal */
+    item = shListGetFirstItem(head);
+    while( item != NULL ) {
+        scan_ptr = (scan_merge_t *)(item->data);
+        if( scan_ptr->count != 0 )
+            scan_ptr->count--;
+        item = shListGetNextItem(head, item);
+    }
+
+    for(i=0;( i < number_items );i++) { /* Find/Add new items */
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+        res_ptr = results[i];
+#else
+        res_ptr = &(results[i]);
+#endif
+        item = shListFindItem( head, res_ptr, scan_equal );
+        if( item ) {
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+            scan_ssid_t *p_ssid;
+            scan_result_t *new_ptr;
+#endif
+            scan_ptr = (scan_merge_t *)(item->data);
+            copy_scan_res(&(scan_ptr->scanres), res_ptr);
+            scan_ptr->count = SCAN_MERGE_COUNT;
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+	    p_ssid = scan_get_ssid(res_ptr);
+            if (p_ssid && IS_HIDDEN_AP(p_ssid)) {
+                new_ptr = scan_dup(res_ptr);
+                if (new_ptr) {
+                    results[i] = new_ptr;
+                    os_free(res_ptr);
+                }
+            }
+#endif
+        }
+        else {
+            scan_add(head, res_ptr);
+        }
+    }
+
+    item = shListGetFirstItem( head );  /* Add/Remove missing items */
+    while( item != NULL ) {
+        del_item = NULL;
+        scan_ptr = (scan_merge_t *)(item->data);
+        if( scan_ptr->count != SCAN_MERGE_COUNT ) {
+            if( !force_flag && ((scan_ptr->count == 0) ||
+                (mydrv->last_scan == SCAN_TYPE_NORMAL_ACTIVE)) ) {
+                del_item = item;
+            }
+            else {
+                if( number_items < max_size ) {
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+                    res_ptr = scan_dup(&(scan_ptr->scanres));
+                    if (res_ptr) {
+                        results[number_items] = res_ptr;
+                        number_items++;
+                    }
+#else
+                    os_memcpy(&(results[number_items]),
+                          &(scan_ptr->scanres), sizeof(scan_result_t));
+                    number_items++;
+#endif
+                }
+            }
+        }
+        item = shListGetNextItem(head, item);
+        shListDelItem(head, del_item, scan_free);
+    }
+
+    return( number_items );
+}
+
+/*-----------------------------------------------------------------------------
+Routine Name: scan_get_by_bssid
+Routine Description: Gets scan_result pointer to item by bssid
+Arguments:
+   mydrv   - pointer to private driver data structure
+   bssid   - pointer to bssid value
+Return Value: pointer to scan_result item
+-----------------------------------------------------------------------------*/
+scan_result_t *scan_get_by_bssid( struct wpa_driver_ti_data *mydrv, u8 *bssid )
+{
+    SHLIST *head = &(mydrv->scan_merge_list);
+    SHLIST *item;
+    scan_result_t *cur_res;
+    scan_ssid_t *p_ssid;
+
+    item = shListGetFirstItem(head);
+    if( item == NULL )
+        return( NULL );
+    do {
+        cur_res = (scan_result_t *)&(((scan_merge_t *)(item->data))->scanres);
+        p_ssid = scan_get_ssid(cur_res);
+        if( (!os_memcmp(cur_res->bssid, bssid, ETH_ALEN)) &&
+            (!IS_HIDDEN_AP(p_ssid)) ) {
+            return( cur_res );
+        }
+        item = shListGetNextItem(head, item);
+    } while( item != NULL );
+
+    return( NULL );
+}
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/src/utils/scanmerge.h wpa_supplicant_new/src/utils/scanmerge.h
--- wpa_supplicant_original/src/utils/scanmerge.h	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant_new/src/utils/scanmerge.h	2011-03-23 16:18:41.063711000 +0200
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*-------------------------------------------------------------------*/
+#ifndef _SCANMERGE_H_
+#define _SCANMERGE_H_
+
+#include "common.h"
+#include "driver.h"
+#include "driver_ti.h"
+
+#define SCAN_MERGE_COUNT        4
+
+typedef
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+    struct wpa_scan_res
+#else
+    struct wpa_scan_result
+#endif
+scan_result_t;
+
+typedef struct {
+    u8 ssid[MAX_SSID_LEN];
+    size_t ssid_len;
+} scan_ssid_t;
+
+typedef struct SCANMERGE_STRUCT {
+    unsigned long count;
+    scan_result_t scanres;
+} scan_merge_t;
+
+void scan_init( struct wpa_driver_ti_data *mydrv );
+void scan_exit( struct wpa_driver_ti_data *mydrv );
+unsigned long scan_count( struct wpa_driver_ti_data *mydrv );
+scan_ssid_t *scan_get_ssid( scan_result_t *res_ptr );
+#ifdef WPA_SUPPLICANT_VER_0_6_X
+unsigned int scan_merge( struct wpa_driver_ti_data *mydrv,
+                         scan_result_t **results, int force_flag,
+                         unsigned int number_items, unsigned int max_size );
+#else
+unsigned int scan_merge( struct wpa_driver_ti_data *mydrv,
+                         scan_result_t *results, int force_flag,
+                         unsigned int number_items, unsigned int max_size );
+#endif
+scan_result_t *scan_get_by_bssid( struct wpa_driver_ti_data *mydrv, u8 *bssid );
+#endif
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/src/utils/shlist.c wpa_supplicant_new/src/utils/shlist.c
--- wpa_supplicant_original/src/utils/shlist.c	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant_new/src/utils/shlist.c	2011-03-23 16:18:41.085736000 +0200
@@ -0,0 +1,185 @@
+/*-------------------------------------------------------------------*/
+/*                         List  Functionality                       */
+/*-------------------------------------------------------------------*/
+/* #define SH_LIST_DEBUG */
+/*-------------------------------------------------------------------*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "shlist.h"
+/*-------------------------------------------------------------------*/
+void shListInitList( SHLIST *listPtr )
+{
+  listPtr->data = (void *)0L;
+  listPtr->next = listPtr;
+  listPtr->prev = listPtr;
+}
+
+SHLIST *shListFindItem( SHLIST *head, void *val, shListEqual func )
+{
+  SHLIST *item;
+
+  for(item=head->next;( item != head );item=item->next)
+    if( func ) {
+      if( func( val, item->data ) ) {
+        return( item );
+      }
+    }
+    else {
+      if( item->data == val ) {
+        return( item );
+      }
+    }
+  return( NULL );
+}
+
+SHLIST *shListGetLastItem( SHLIST *head )
+{
+  if( head->prev != head )
+    return( head->prev );
+  return( NULL );
+}
+
+SHLIST *shListGetFirstItem( SHLIST *head )
+{
+  if( head->next != head )
+    return( head->next );
+  return( NULL );
+}
+
+SHLIST *shListGetNItem( SHLIST *head, unsigned long num )
+{
+  SHLIST *item;
+  unsigned long i;
+
+  for(i=0,item=head->next;( (i < num) && (item != head) );i++,item=item->next);
+  if( item != head )
+    return( item );
+  return( NULL );
+}
+
+SHLIST *shListGetNextItem( SHLIST *head, SHLIST *item )
+{
+  if( item == NULL )
+    return( NULL );
+  if( item->next != head )
+    return( item->next );
+  return( NULL );
+}
+
+SHLIST *shListGetPrevItem( SHLIST *head, SHLIST *item )
+{
+  if( item == NULL )
+    return( NULL );
+  if( item->prev != head )
+    return( item->prev );
+  return( NULL );
+}
+
+void shListDelItem( SHLIST *head, SHLIST *item, shListFree func )
+{
+  if( item == NULL )
+    return;
+#ifdef SH_LIST_DEBUG
+  fprintf(stderr, "Del %lx\n", (unsigned long)(item->data));
+#endif
+  (item->prev)->next = item->next;
+  (item->next)->prev = item->prev;
+  if( func && item->data ) {
+    func( (void *)(item->data) );
+  }
+  free( item );
+  head->data = (void *)((unsigned long)(head->data) - 1);
+}
+
+void shListInsFirstItem( SHLIST *head, void *val )
+{ /* Insert to the beginning of the list */
+  SHLIST *item;
+
+  item = (SHLIST *)malloc( sizeof(SHLIST) );
+  if( item == NULL )
+    return;
+  item->data = val;
+  item->next = head->next;
+  item->prev = head;
+  (head->next)->prev = item;
+  head->next = item;
+#ifdef SH_LIST_DEBUG
+  fprintf(stderr, "Ins First %lx\n", (unsigned long)(item->data));
+#endif
+  head->data = (void *)((unsigned long)(head->data) + 1);
+}
+
+void shListInsLastItem( SHLIST *head, void *val )
+{ /* Insert to the end of the list */
+  SHLIST *item;
+
+  item = (SHLIST *)malloc( sizeof(SHLIST) );
+  if( item == NULL )
+    return;
+  item->data = val;
+  item->next = head;
+  item->prev = head->prev;
+  (head->prev)->next = item;
+  head->prev = item;
+#ifdef SH_LIST_DEBUG
+  fprintf(stderr, "Ins Last %lx\n", (unsigned long)(item->data));
+#endif
+  head->data = (void *)((unsigned long)(head->data) + 1);
+}
+
+void shListInsBeforeItem( SHLIST *head, void *val, void *etal, 
+                          shListCmp func )
+{
+  SHLIST *item, *iptr;
+
+  if( func == NULL )
+    shListInsFirstItem( head, val );
+  else {
+    item = (SHLIST *)malloc( sizeof(SHLIST) );
+    if( item == NULL )
+      return;
+    item->data = val;
+    for(iptr=head->next;( iptr != head );iptr=iptr->next)
+      if( func( val, iptr->data, etal ) )
+         break;
+    item->next = iptr;
+    item->prev = iptr->prev;
+    (iptr->prev)->next = item;
+    iptr->prev = item;
+#ifdef SH_LIST_DEBUG
+    fprintf(stderr, "Ins Before %lx\n", (unsigned long)(item->data));
+#endif
+    head->data = (void *)((unsigned long)(head->data) + 1);
+  }
+}
+
+void shListDelAllItems( SHLIST *head, shListFree func )
+{
+  SHLIST *item;
+
+  for(item=head->next;( item != head );) {
+    shListDelItem( head, item, func );
+    item = head->next;
+  }
+  head->data = (void *)0L;
+}
+
+void shListPrintAllItems( SHLIST *head, shListPrint func )
+{
+#ifdef SH_LIST_DEBUG
+  SHLIST *item;
+
+  for(item=head->next;( item != head );item=item->next)
+    if( func ) {
+      func(item->data);
+    }
+    else {
+      fprintf(stderr, "Item: %lx\n",(unsigned long)(item->data));
+    }
+#endif
+}
+
+unsigned long shListGetCount( SHLIST *head )
+{
+  return( (unsigned long)(head->data) );
+}
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/src/utils/shlist.h wpa_supplicant_new/src/utils/shlist.h
--- wpa_supplicant_original/src/utils/shlist.h	1970-01-01 02:00:00.000000000 +0200
+++ wpa_supplicant_new/src/utils/shlist.h	2011-03-23 16:18:41.108682000 +0200
@@ -0,0 +1,34 @@
+/*-------------------------------------------------------------------*/
+/*                         List  Functionality                       */
+/*-------------------------------------------------------------------*/
+#ifndef _SHLIST_H_
+#define _SHLIST_H_
+
+typedef struct SHLIST_STRUC {
+  void *data;
+  struct SHLIST_STRUC *next;
+  struct SHLIST_STRUC *prev;
+} SHLIST;
+
+typedef int (*shListCmp)( void *valo, void *valn, void *etalon );
+typedef int (*shListPrint)( void *val );
+typedef void (*shListFree)( void *val );
+typedef int (*shListEqual)( void *val,  void *idata );
+
+void shListInitList( SHLIST *listPtr );
+SHLIST *shListFindItem( SHLIST *head, void *val, shListEqual func );
+SHLIST *shListGetFirstItem( SHLIST *head );
+SHLIST *shListGetNItem( SHLIST *head, unsigned long num );
+SHLIST *shListGetLastItem( SHLIST *head );
+SHLIST *shListGetNextItem( SHLIST *head, SHLIST *item );
+SHLIST *shListGetPrevItem( SHLIST *head, SHLIST *item );
+void shListDelItem( SHLIST *head, SHLIST *item, shListFree func );
+void shListInsFirstItem( SHLIST *head, void *val );
+void shListInsBeforeItem( SHLIST *head, void *val, void *etalon, 
+                          shListCmp func );
+void shListInsLastItem( SHLIST *head, void *val );
+void shListDelAllItems( SHLIST *head, shListFree func );
+void shListPrintAllItems( SHLIST *head, shListPrint func );
+unsigned long shListGetCount( SHLIST *head );
+
+#endif
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/src/wps/wps_attr_process.c wpa_supplicant_new/src/wps/wps_attr_process.c
--- wpa_supplicant_original/src/wps/wps_attr_process.c	2011-03-23 16:18:12.138058000 +0200
+++ wpa_supplicant_new/src/wps/wps_attr_process.c	2011-03-23 16:18:41.365653000 +0200
@@ -177,6 +177,13 @@
 	if (key == NULL) {
 		wpa_printf(MSG_DEBUG, "WPS: Credential did not include "
 			   "Network Key");
+		if (cred->auth_type == WPS_AUTH_OPEN &&
+		    cred->encr_type == WPS_ENCR_NONE) {
+			wpa_printf(MSG_DEBUG, "WPS: Workaround - Allow "
+				   "missing mandatory Network Key attribute "
+				   "for open network");
+			return 0;
+		}
 		return -1;
 	}
 
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/wpa_supplicant.c wpa_supplicant_new/wpa_supplicant.c
--- wpa_supplicant_original/wpa_supplicant.c	2011-03-23 16:18:14.631915000 +0200
+++ wpa_supplicant_new/wpa_supplicant.c	2011-03-23 16:18:43.091527000 +0200
@@ -239,7 +239,6 @@
 	wpa_blacklist_del(wpa_s, wpa_s->bssid);
 }
 
-
 /**
  * wpa_eapol_set_wep_key - set WEP key for the driver
  * @ctx: Pointer to wpa_supplicant data (wpa_s)
@@ -967,9 +966,9 @@
 	struct wpa_driver_associate_params params;
 	int wep_keys_set = 0;
 	struct wpa_driver_capa capa;
-	int assoc_failed = 0;
-	int mode = wpa_s->adhoc = 0;
+	int assoc_failed = 0, mode;
 
+	mode = wpa_s->adhoc = 0;
 	wpa_s->reassociate = 0;
 	if (bss) {
 #ifdef CONFIG_IEEE80211R
@@ -981,10 +980,9 @@
 			ie ? wpa_ssid_txt(ie + 2, ie[1]) : "", bss->freq);
 		os_memset(wpa_s->bssid, 0, ETH_ALEN);
 		os_memcpy(wpa_s->pending_bssid, bss->bssid, ETH_ALEN);
-		wpa_s->link_speed = wpa_scan_get_max_rate(bss) * 500000;
-		wpa_s->rssi = bss->level;
+
 		if (bss->caps & IEEE80211_CAP_IBSS)
-			mode = 1;
+           mode = 1;
 #ifdef CONFIG_IEEE80211R
 		ie = wpa_scan_get_ie(bss, WLAN_EID_MOBILITY_DOMAIN);
 		if (ie && ie[1] >= MOBILITY_DOMAIN_ID_LEN)
@@ -1010,15 +1008,15 @@
 		wpa_msg(wpa_s, MSG_INFO, "Trying to associate with SSID '%s'",
 			wpa_ssid_txt(ssid->ssid, ssid->ssid_len));
 		os_memset(wpa_s->pending_bssid, 0, ETH_ALEN);
+		mode = ssid->mode;
 	}
 	wpa_supplicant_cancel_scan(wpa_s);
-	mode = ssid->mode;
 
 	/* Starting new association, so clear the possibly used WPA IE from the
 	 * previous association. */
 	wpa_sm_set_assoc_wpa_ie(wpa_s->wpa, NULL, 0);
 
-	if (wpa_drv_set_mode(wpa_s, ssid->mode)) {
+	if (wpa_drv_set_mode(wpa_s, mode)) {
 		wpa_printf(MSG_WARNING, "Failed to set operating mode");
 		assoc_failed = 1;
 	}
@@ -1515,30 +1513,6 @@
 	return NULL;
 }
 
-int wpa_drv_scan(struct wpa_supplicant *wpa_s, struct wpa_ssid **ssid_ptr)
-{
-	u8 *ssid_nm = NULL;
-	size_t ssid_len = 0;
-	int ret = -1;
-
-	if (wpa_s->driver->combo_scan) {
-		ret = wpa_s->driver->combo_scan(wpa_s->drv_priv, ssid_ptr,
-						wpa_s->conf->ssid);
-		if (!ret) {
-			wpa_s->prev_scan_ssid = (*ssid_ptr) ?
-					(*ssid_ptr) : BROADCAST_SSID_SCAN;
-		}
-	}
-	else if (wpa_s->driver->scan) {
-		if (*ssid_ptr) {
-			ssid_nm = (*ssid_ptr)->ssid;
-			ssid_len = (*ssid_ptr)->ssid_len;
-		}
-
-		ret = wpa_s->driver->scan(wpa_s->drv_priv, ssid_nm, ssid_len);
-	}
-	return ret;
-}
 
 static int wpa_supplicant_set_driver(struct wpa_supplicant *wpa_s,
 				     const char *name)
diff -Naur --exclude='*.keep' --exclude='*.gitignore' wpa_supplicant_original/wpa_supplicant_i.h wpa_supplicant_new/wpa_supplicant_i.h
--- wpa_supplicant_original/wpa_supplicant_i.h	2011-03-23 16:18:08.147386000 +0200
+++ wpa_supplicant_new/wpa_supplicant_i.h	2011-03-23 16:18:43.135497000 +0200
@@ -371,6 +371,14 @@
 #ifdef ANDROID
 	int scan_interval; /* time between scans when no APs available */
 #endif
+
+    /* TI Chnage */
+    int scan_initiator; /* Used to determine the scan initiator according
+                         * to scan_req, but as scan_req goes back to zero 
+                         * for next request, this parameter is passed to 
+                         * driver_ti to decide which scan to perform 
+                         * (one-shot or periodic) */
+    /* */
 };
 
 
@@ -422,7 +430,6 @@
 void wpa_supplicant_cancel_scan(struct wpa_supplicant *wpa_s);
 void wpa_supplicant_notify_scanning(struct wpa_supplicant *wpa_s,
 				    int scanning);
-int wpa_drv_scan(struct wpa_supplicant *wpa_s, struct wpa_ssid **ssid_prt);
 
 /* events.c */
 void wpa_supplicant_mark_disassoc(struct wpa_supplicant *wpa_s);
@@ -519,6 +526,15 @@
 	return -1;
 }
 
+static inline int wpa_drv_scan(struct wpa_supplicant *wpa_s, const u8 *ssid,
+			       size_t ssid_len)
+{
+	if (wpa_s->driver->scan) {
+		return wpa_s->driver->scan(wpa_s->drv_priv, ssid, ssid_len);
+	}
+	return -1;
+}
+
 static inline int wpa_drv_get_scan_results(struct wpa_supplicant *wpa_s,
 					   struct wpa_scan_result *results,
 					   size_t max_size)
@@ -783,6 +799,7 @@
 static inline int wpa_drv_driver_cmd(struct wpa_supplicant *wpa_s,
 					  char *cmd, char *buf, size_t buf_len)
 {
+    wpa_printf(MSG_ERROR, "in wpa_drv_driver_cmd\n");
 	if (wpa_s->driver->driver_cmd)
 		return wpa_s->driver->driver_cmd(wpa_s->drv_priv, cmd, buf, buf_len);
 	return -1;
